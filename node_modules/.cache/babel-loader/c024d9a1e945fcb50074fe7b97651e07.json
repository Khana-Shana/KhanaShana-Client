{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = undefined;\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _extends2 = require('babel-runtime/helpers/extends');\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _react = require('react');\n\nvar React = _interopRequireWildcard(_react);\n\nvar _clsx = require('clsx');\n\nvar _clsx2 = _interopRequireDefault(_clsx);\n\nvar _calculateSizeAndPositionDataAndUpdateScrollOffset = require('./utils/calculateSizeAndPositionDataAndUpdateScrollOffset');\n\nvar _calculateSizeAndPositionDataAndUpdateScrollOffset2 = _interopRequireDefault(_calculateSizeAndPositionDataAndUpdateScrollOffset);\n\nvar _ScalingCellSizeAndPositionManager = require('./utils/ScalingCellSizeAndPositionManager');\n\nvar _ScalingCellSizeAndPositionManager2 = _interopRequireDefault(_ScalingCellSizeAndPositionManager);\n\nvar _createCallbackMemoizer = require('../utils/createCallbackMemoizer');\n\nvar _createCallbackMemoizer2 = _interopRequireDefault(_createCallbackMemoizer);\n\nvar _defaultOverscanIndicesGetter = require('./defaultOverscanIndicesGetter');\n\nvar _defaultOverscanIndicesGetter2 = _interopRequireDefault(_defaultOverscanIndicesGetter);\n\nvar _updateScrollIndexHelper = require('./utils/updateScrollIndexHelper');\n\nvar _updateScrollIndexHelper2 = _interopRequireDefault(_updateScrollIndexHelper);\n\nvar _defaultCellRangeRenderer = require('./defaultCellRangeRenderer');\n\nvar _defaultCellRangeRenderer2 = _interopRequireDefault(_defaultCellRangeRenderer);\n\nvar _scrollbarSize = require('dom-helpers/scrollbarSize');\n\nvar _scrollbarSize2 = _interopRequireDefault(_scrollbarSize);\n\nvar _reactLifecyclesCompat = require('react-lifecycles-compat');\n\nvar _requestAnimationTimeout = require('../utils/requestAnimationTimeout');\n\nvar _types = require('./types');\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.\n * This improves performance and makes scrolling smoother.\n */\n\n\nvar DEFAULT_SCROLLING_RESET_TIME_INTERVAL = exports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = 150;\n/**\n * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.\n * This prevents Grid from interrupting mouse-wheel animations (see issue #2).\n */\n\nvar SCROLL_POSITION_CHANGE_REASONS = {\n  OBSERVED: 'observed',\n  REQUESTED: 'requested'\n};\n\nvar renderNull = function renderNull() {\n  return null;\n};\n/**\n * Renders tabular data with virtualization along the vertical and horizontal axes.\n * Row heights and column widths must be known ahead of time and specified as properties.\n */\n\n\nvar Grid = function (_React$PureComponent) {\n  (0, _inherits3.default)(Grid, _React$PureComponent); // Invokes onSectionRendered callback only when start/stop row or column indices change\n\n  function Grid(props) {\n    (0, _classCallCheck3.default)(this, Grid);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (Grid.__proto__ || (0, _getPrototypeOf2.default)(Grid)).call(this, props));\n\n    _this._onGridRenderedMemoizer = (0, _createCallbackMemoizer2.default)();\n    _this._onScrollMemoizer = (0, _createCallbackMemoizer2.default)(false);\n    _this._deferredInvalidateColumnIndex = null;\n    _this._deferredInvalidateRowIndex = null;\n    _this._recomputeScrollLeftFlag = false;\n    _this._recomputeScrollTopFlag = false;\n    _this._horizontalScrollBarSize = 0;\n    _this._verticalScrollBarSize = 0;\n    _this._scrollbarPresenceChanged = false;\n    _this._renderedColumnStartIndex = 0;\n    _this._renderedColumnStopIndex = 0;\n    _this._renderedRowStartIndex = 0;\n    _this._renderedRowStopIndex = 0;\n    _this._styleCache = {};\n    _this._cellCache = {};\n\n    _this._debounceScrollEndedCallback = function () {\n      _this._disablePointerEventsTimeoutId = null; // isScrolling is used to determine if we reset styleCache\n\n      _this.setState({\n        isScrolling: false,\n        needToResetStyleCache: false\n      });\n    };\n\n    _this._invokeOnGridRenderedHelper = function () {\n      var onSectionRendered = _this.props.onSectionRendered;\n\n      _this._onGridRenderedMemoizer({\n        callback: onSectionRendered,\n        indices: {\n          columnOverscanStartIndex: _this._columnStartIndex,\n          columnOverscanStopIndex: _this._columnStopIndex,\n          columnStartIndex: _this._renderedColumnStartIndex,\n          columnStopIndex: _this._renderedColumnStopIndex,\n          rowOverscanStartIndex: _this._rowStartIndex,\n          rowOverscanStopIndex: _this._rowStopIndex,\n          rowStartIndex: _this._renderedRowStartIndex,\n          rowStopIndex: _this._renderedRowStopIndex\n        }\n      });\n    };\n\n    _this._setScrollingContainerRef = function (ref) {\n      _this._scrollingContainer = ref;\n    };\n\n    _this._onScroll = function (event) {\n      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.\n      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.\n      // See issue #404 for more information.\n      if (event.target === _this._scrollingContainer) {\n        _this.handleScrollEvent(event.target);\n      }\n    };\n\n    var columnSizeAndPositionManager = new _ScalingCellSizeAndPositionManager2.default({\n      cellCount: props.columnCount,\n      cellSizeGetter: function cellSizeGetter(params) {\n        return Grid._wrapSizeGetter(props.columnWidth)(params);\n      },\n      estimatedCellSize: Grid._getEstimatedColumnSize(props)\n    });\n    var rowSizeAndPositionManager = new _ScalingCellSizeAndPositionManager2.default({\n      cellCount: props.rowCount,\n      cellSizeGetter: function cellSizeGetter(params) {\n        return Grid._wrapSizeGetter(props.rowHeight)(params);\n      },\n      estimatedCellSize: Grid._getEstimatedRowSize(props)\n    });\n    _this.state = {\n      instanceProps: {\n        columnSizeAndPositionManager: columnSizeAndPositionManager,\n        rowSizeAndPositionManager: rowSizeAndPositionManager,\n        prevColumnWidth: props.columnWidth,\n        prevRowHeight: props.rowHeight,\n        prevColumnCount: props.columnCount,\n        prevRowCount: props.rowCount,\n        prevIsScrolling: props.isScrolling === true,\n        prevScrollToColumn: props.scrollToColumn,\n        prevScrollToRow: props.scrollToRow,\n        scrollbarSize: 0,\n        scrollbarSizeMeasured: false\n      },\n      isScrolling: false,\n      scrollDirectionHorizontal: _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD,\n      scrollDirectionVertical: _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD,\n      scrollLeft: 0,\n      scrollTop: 0,\n      scrollPositionChangeReason: null,\n      needToResetStyleCache: false\n    };\n\n    if (props.scrollToRow > 0) {\n      _this._initialScrollTop = _this._getCalculatedScrollTop(props, _this.state);\n    }\n\n    if (props.scrollToColumn > 0) {\n      _this._initialScrollLeft = _this._getCalculatedScrollLeft(props, _this.state);\n    }\n\n    return _this;\n  }\n  /**\n   * Gets offsets for a given cell and alignment.\n   */\n\n\n  (0, _createClass3.default)(Grid, [{\n    key: 'getOffsetForCell',\n    value: function getOffsetForCell() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$alignment = _ref.alignment,\n          alignment = _ref$alignment === undefined ? this.props.scrollToAlignment : _ref$alignment,\n          _ref$columnIndex = _ref.columnIndex,\n          columnIndex = _ref$columnIndex === undefined ? this.props.scrollToColumn : _ref$columnIndex,\n          _ref$rowIndex = _ref.rowIndex,\n          rowIndex = _ref$rowIndex === undefined ? this.props.scrollToRow : _ref$rowIndex;\n\n      var offsetProps = (0, _extends3.default)({}, this.props, {\n        scrollToAlignment: alignment,\n        scrollToColumn: columnIndex,\n        scrollToRow: rowIndex\n      });\n      return {\n        scrollLeft: this._getCalculatedScrollLeft(offsetProps),\n        scrollTop: this._getCalculatedScrollTop(offsetProps)\n      };\n    }\n    /**\n     * Gets estimated total rows' height.\n     */\n\n  }, {\n    key: 'getTotalRowsHeight',\n    value: function getTotalRowsHeight() {\n      return this.state.instanceProps.rowSizeAndPositionManager.getTotalSize();\n    }\n    /**\n     * Gets estimated total columns' width.\n     */\n\n  }, {\n    key: 'getTotalColumnsWidth',\n    value: function getTotalColumnsWidth() {\n      return this.state.instanceProps.columnSizeAndPositionManager.getTotalSize();\n    }\n    /**\n     * This method handles a scroll event originating from an external scroll control.\n     * It's an advanced method and should probably not be used unless you're implementing a custom scroll-bar solution.\n     */\n\n  }, {\n    key: 'handleScrollEvent',\n    value: function handleScrollEvent(_ref2) {\n      var _ref2$scrollLeft = _ref2.scrollLeft,\n          scrollLeftParam = _ref2$scrollLeft === undefined ? 0 : _ref2$scrollLeft,\n          _ref2$scrollTop = _ref2.scrollTop,\n          scrollTopParam = _ref2$scrollTop === undefined ? 0 : _ref2$scrollTop; // On iOS, we can arrive at negative offsets by swiping past the start.\n      // To prevent flicker here, we make playing in the negative offset zone cause nothing to happen.\n\n      if (scrollTopParam < 0) {\n        return;\n      } // Prevent pointer events from interrupting a smooth scroll\n\n\n      this._debounceScrollEnded();\n\n      var _props = this.props,\n          autoHeight = _props.autoHeight,\n          autoWidth = _props.autoWidth,\n          height = _props.height,\n          width = _props.width;\n      var instanceProps = this.state.instanceProps; // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,\n      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.\n      // This causes a series of rapid renders that is slow for long lists.\n      // We can avoid that by doing some simple bounds checking to ensure that scroll offsets never exceed their bounds.\n\n      var scrollbarSize = instanceProps.scrollbarSize;\n      var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n      var scrollLeft = Math.min(Math.max(0, totalColumnsWidth - width + scrollbarSize), scrollLeftParam);\n      var scrollTop = Math.min(Math.max(0, totalRowsHeight - height + scrollbarSize), scrollTopParam); // Certain devices (like Apple touchpad) rapid-fire duplicate events.\n      // Don't force a re-render if this is the case.\n      // The mouse may move faster then the animation frame does.\n      // Use requestAnimationFrame to avoid over-updating.\n\n      if (this.state.scrollLeft !== scrollLeft || this.state.scrollTop !== scrollTop) {\n        // Track scrolling direction so we can more efficiently overscan rows to reduce empty space around the edges while scrolling.\n        // Don't change direction for an axis unless scroll offset has changed.\n        var _scrollDirectionHorizontal = scrollLeft !== this.state.scrollLeft ? scrollLeft > this.state.scrollLeft ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionHorizontal;\n\n        var _scrollDirectionVertical = scrollTop !== this.state.scrollTop ? scrollTop > this.state.scrollTop ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionVertical;\n\n        var newState = {\n          isScrolling: true,\n          scrollDirectionHorizontal: _scrollDirectionHorizontal,\n          scrollDirectionVertical: _scrollDirectionVertical,\n          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.OBSERVED\n        };\n\n        if (!autoHeight) {\n          newState.scrollTop = scrollTop;\n        }\n\n        if (!autoWidth) {\n          newState.scrollLeft = scrollLeft;\n        }\n\n        newState.needToResetStyleCache = false;\n        this.setState(newState);\n      }\n\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop,\n        totalColumnsWidth: totalColumnsWidth,\n        totalRowsHeight: totalRowsHeight\n      });\n    }\n    /**\n     * Invalidate Grid size and recompute visible cells.\n     * This is a deferred wrapper for recomputeGridSize().\n     * It sets a flag to be evaluated on cDM/cDU to avoid unnecessary renders.\n     * This method is intended for advanced use-cases like CellMeasurer.\n     */\n    // @TODO (bvaughn) Add automated test coverage for this.\n\n  }, {\n    key: 'invalidateCellSizeAfterRender',\n    value: function invalidateCellSizeAfterRender(_ref3) {\n      var columnIndex = _ref3.columnIndex,\n          rowIndex = _ref3.rowIndex;\n      this._deferredInvalidateColumnIndex = typeof this._deferredInvalidateColumnIndex === 'number' ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex;\n      this._deferredInvalidateRowIndex = typeof this._deferredInvalidateRowIndex === 'number' ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;\n    }\n    /**\n     * Pre-measure all columns and rows in a Grid.\n     * Typically cells are only measured as needed and estimated sizes are used for cells that have not yet been measured.\n     * This method ensures that the next call to getTotalSize() returns an exact size (as opposed to just an estimated one).\n     */\n\n  }, {\n    key: 'measureAllCells',\n    value: function measureAllCells() {\n      var _props2 = this.props,\n          columnCount = _props2.columnCount,\n          rowCount = _props2.rowCount;\n      var instanceProps = this.state.instanceProps;\n      instanceProps.columnSizeAndPositionManager.getSizeAndPositionOfCell(columnCount - 1);\n      instanceProps.rowSizeAndPositionManager.getSizeAndPositionOfCell(rowCount - 1);\n    }\n    /**\n     * Forced recompute of row heights and column widths.\n     * This function should be called if dynamic column or row sizes have changed but nothing else has.\n     * Since Grid only receives :columnCount and :rowCount it has no way of detecting when the underlying data changes.\n     */\n\n  }, {\n    key: 'recomputeGridSize',\n    value: function recomputeGridSize() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref4$columnIndex = _ref4.columnIndex,\n          columnIndex = _ref4$columnIndex === undefined ? 0 : _ref4$columnIndex,\n          _ref4$rowIndex = _ref4.rowIndex,\n          rowIndex = _ref4$rowIndex === undefined ? 0 : _ref4$rowIndex;\n\n      var _props3 = this.props,\n          scrollToColumn = _props3.scrollToColumn,\n          scrollToRow = _props3.scrollToRow;\n      var instanceProps = this.state.instanceProps;\n      instanceProps.columnSizeAndPositionManager.resetCell(columnIndex);\n      instanceProps.rowSizeAndPositionManager.resetCell(rowIndex); // Cell sizes may be determined by a function property.\n      // In this case the cDU handler can't know if they changed.\n      // Store this flag to let the next cDU pass know it needs to recompute the scroll offset.\n\n      this._recomputeScrollLeftFlag = scrollToColumn >= 0 && (this.state.scrollDirectionHorizontal === _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD ? columnIndex <= scrollToColumn : columnIndex >= scrollToColumn);\n      this._recomputeScrollTopFlag = scrollToRow >= 0 && (this.state.scrollDirectionVertical === _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD ? rowIndex <= scrollToRow : rowIndex >= scrollToRow); // Clear cell cache in case we are scrolling;\n      // Invalid row heights likely mean invalid cached content as well.\n\n      this._styleCache = {};\n      this._cellCache = {};\n      this.forceUpdate();\n    }\n    /**\n     * Ensure column and row are visible.\n     */\n\n  }, {\n    key: 'scrollToCell',\n    value: function scrollToCell(_ref5) {\n      var columnIndex = _ref5.columnIndex,\n          rowIndex = _ref5.rowIndex;\n      var columnCount = this.props.columnCount;\n      var props = this.props; // Don't adjust scroll offset for single-column grids (eg List, Table).\n      // This can cause a funky scroll offset because of the vertical scrollbar width.\n\n      if (columnCount > 1 && columnIndex !== undefined) {\n        this._updateScrollLeftForScrollToColumn((0, _extends3.default)({}, props, {\n          scrollToColumn: columnIndex\n        }));\n      }\n\n      if (rowIndex !== undefined) {\n        this._updateScrollTopForScrollToRow((0, _extends3.default)({}, props, {\n          scrollToRow: rowIndex\n        }));\n      }\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var _props4 = this.props,\n          getScrollbarSize = _props4.getScrollbarSize,\n          height = _props4.height,\n          scrollLeft = _props4.scrollLeft,\n          scrollToColumn = _props4.scrollToColumn,\n          scrollTop = _props4.scrollTop,\n          scrollToRow = _props4.scrollToRow,\n          width = _props4.width;\n      var instanceProps = this.state.instanceProps; // Reset initial offsets to be ignored in browser\n\n      this._initialScrollTop = 0;\n      this._initialScrollLeft = 0; // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\n      // We must do this at the start of the method as we may calculate and update scroll position below.\n\n      this._handleInvalidatedGridSize(); // If this component was first rendered server-side, scrollbar size will be undefined.\n      // In that event we need to remeasure.\n\n\n      if (!instanceProps.scrollbarSizeMeasured) {\n        this.setState(function (prevState) {\n          var stateUpdate = (0, _extends3.default)({}, prevState, {\n            needToResetStyleCache: false\n          });\n          stateUpdate.instanceProps.scrollbarSize = getScrollbarSize();\n          stateUpdate.instanceProps.scrollbarSizeMeasured = true;\n          return stateUpdate;\n        });\n      }\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0 || typeof scrollTop === 'number' && scrollTop >= 0) {\n        var stateUpdate = Grid._getScrollToPositionStateUpdate({\n          prevState: this.state,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        });\n\n        if (stateUpdate) {\n          stateUpdate.needToResetStyleCache = false;\n          this.setState(stateUpdate);\n        }\n      } // refs don't work in `react-test-renderer`\n\n\n      if (this._scrollingContainer) {\n        // setting the ref's scrollLeft and scrollTop.\n        // Somehow in MultiGrid the main grid doesn't trigger a update on mount.\n        if (this._scrollingContainer.scrollLeft !== this.state.scrollLeft) {\n          this._scrollingContainer.scrollLeft = this.state.scrollLeft;\n        }\n\n        if (this._scrollingContainer.scrollTop !== this.state.scrollTop) {\n          this._scrollingContainer.scrollTop = this.state.scrollTop;\n        }\n      } // Don't update scroll offset if the size is 0; we don't render any cells in this case.\n      // Setting a state may cause us to later thing we've updated the offce when we haven't.\n\n\n      var sizeIsBiggerThanZero = height > 0 && width > 0;\n\n      if (scrollToColumn >= 0 && sizeIsBiggerThanZero) {\n        this._updateScrollLeftForScrollToColumn();\n      }\n\n      if (scrollToRow >= 0 && sizeIsBiggerThanZero) {\n        this._updateScrollTopForScrollToRow();\n      } // Update onRowsRendered callback\n\n\n      this._invokeOnGridRenderedHelper(); // Initialize onScroll callback\n\n\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft || 0,\n        scrollTop: scrollTop || 0,\n        totalColumnsWidth: instanceProps.columnSizeAndPositionManager.getTotalSize(),\n        totalRowsHeight: instanceProps.rowSizeAndPositionManager.getTotalSize()\n      });\n\n      this._maybeCallOnScrollbarPresenceChange();\n    }\n    /**\n     * @private\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) New scroll-to-cell props have been set\n     */\n\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this2 = this;\n\n      var _props5 = this.props,\n          autoHeight = _props5.autoHeight,\n          autoWidth = _props5.autoWidth,\n          columnCount = _props5.columnCount,\n          height = _props5.height,\n          rowCount = _props5.rowCount,\n          scrollToAlignment = _props5.scrollToAlignment,\n          scrollToColumn = _props5.scrollToColumn,\n          scrollToRow = _props5.scrollToRow,\n          width = _props5.width;\n      var _state = this.state,\n          scrollLeft = _state.scrollLeft,\n          scrollPositionChangeReason = _state.scrollPositionChangeReason,\n          scrollTop = _state.scrollTop,\n          instanceProps = _state.instanceProps; // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\n      // We must do this at the start of the method as we may calculate and update scroll position below.\n\n      this._handleInvalidatedGridSize(); // Handle edge case where column or row count has only just increased over 0.\n      // In this case we may have to restore a previously-specified scroll offset.\n      // For more info see bvaughn/react-virtualized/issues/218\n\n\n      var columnOrRowCountJustIncreasedFromZero = columnCount > 0 && prevProps.columnCount === 0 || rowCount > 0 && prevProps.rowCount === 0; // Make sure requested changes to :scrollLeft or :scrollTop get applied.\n      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,\n      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).\n      // So we only set these when we require an adjustment of the scroll position.\n      // See issue #2 for more information.\n\n      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {\n        // @TRICKY :autoHeight and :autoWidth properties instructs Grid to leave :scrollTop and :scrollLeft management to an external HOC (eg WindowScroller).\n        // In this case we should avoid checking scrollingContainer.scrollTop and scrollingContainer.scrollLeft since it forces layout/flow.\n        if (!autoWidth && scrollLeft >= 0 && (scrollLeft !== this._scrollingContainer.scrollLeft || columnOrRowCountJustIncreasedFromZero)) {\n          this._scrollingContainer.scrollLeft = scrollLeft;\n        }\n\n        if (!autoHeight && scrollTop >= 0 && (scrollTop !== this._scrollingContainer.scrollTop || columnOrRowCountJustIncreasedFromZero)) {\n          this._scrollingContainer.scrollTop = scrollTop;\n        }\n      } // Special case where the previous size was 0:\n      // In this case we don't show any windowed cells at all.\n      // So we should always recalculate offset afterwards.\n\n\n      var sizeJustIncreasedFromZero = (prevProps.width === 0 || prevProps.height === 0) && height > 0 && width > 0; // Update scroll offsets if the current :scrollToColumn or :scrollToRow values requires it\n      // @TODO Do we also need this check or can the one in componentWillUpdate() suffice?\n\n      if (this._recomputeScrollLeftFlag) {\n        this._recomputeScrollLeftFlag = false;\n\n        this._updateScrollLeftForScrollToColumn(this.props);\n      } else {\n        (0, _updateScrollIndexHelper2.default)({\n          cellSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\n          previousCellsCount: prevProps.columnCount,\n          previousCellSize: prevProps.columnWidth,\n          previousScrollToAlignment: prevProps.scrollToAlignment,\n          previousScrollToIndex: prevProps.scrollToColumn,\n          previousSize: prevProps.width,\n          scrollOffset: scrollLeft,\n          scrollToAlignment: scrollToAlignment,\n          scrollToIndex: scrollToColumn,\n          size: width,\n          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,\n          updateScrollIndexCallback: function updateScrollIndexCallback() {\n            return _this2._updateScrollLeftForScrollToColumn(_this2.props);\n          }\n        });\n      }\n\n      if (this._recomputeScrollTopFlag) {\n        this._recomputeScrollTopFlag = false;\n\n        this._updateScrollTopForScrollToRow(this.props);\n      } else {\n        (0, _updateScrollIndexHelper2.default)({\n          cellSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\n          previousCellsCount: prevProps.rowCount,\n          previousCellSize: prevProps.rowHeight,\n          previousScrollToAlignment: prevProps.scrollToAlignment,\n          previousScrollToIndex: prevProps.scrollToRow,\n          previousSize: prevProps.height,\n          scrollOffset: scrollTop,\n          scrollToAlignment: scrollToAlignment,\n          scrollToIndex: scrollToRow,\n          size: height,\n          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,\n          updateScrollIndexCallback: function updateScrollIndexCallback() {\n            return _this2._updateScrollTopForScrollToRow(_this2.props);\n          }\n        });\n      } // Update onRowsRendered callback if start/stop indices have changed\n\n\n      this._invokeOnGridRenderedHelper(); // Changes to :scrollLeft or :scrollTop should also notify :onScroll listeners\n\n\n      if (scrollLeft !== prevState.scrollLeft || scrollTop !== prevState.scrollTop) {\n        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n\n        this._invokeOnScrollMemoizer({\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          totalColumnsWidth: totalColumnsWidth,\n          totalRowsHeight: totalRowsHeight\n        });\n      }\n\n      this._maybeCallOnScrollbarPresenceChange();\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      if (this._disablePointerEventsTimeoutId) {\n        (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId);\n      }\n    }\n    /**\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) Empty content (0 rows or columns)\n     * 2) New scroll props overriding the current state\n     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid\n     */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props6 = this.props,\n          autoContainerWidth = _props6.autoContainerWidth,\n          autoHeight = _props6.autoHeight,\n          autoWidth = _props6.autoWidth,\n          className = _props6.className,\n          containerProps = _props6.containerProps,\n          containerRole = _props6.containerRole,\n          containerStyle = _props6.containerStyle,\n          height = _props6.height,\n          id = _props6.id,\n          noContentRenderer = _props6.noContentRenderer,\n          role = _props6.role,\n          style = _props6.style,\n          tabIndex = _props6.tabIndex,\n          width = _props6.width;\n      var _state2 = this.state,\n          instanceProps = _state2.instanceProps,\n          needToResetStyleCache = _state2.needToResetStyleCache;\n\n      var isScrolling = this._isScrolling();\n\n      var gridStyle = {\n        boxSizing: 'border-box',\n        direction: 'ltr',\n        height: autoHeight ? 'auto' : height,\n        position: 'relative',\n        width: autoWidth ? 'auto' : width,\n        WebkitOverflowScrolling: 'touch',\n        willChange: 'transform'\n      };\n\n      if (needToResetStyleCache) {\n        this._styleCache = {};\n      } // calculate _styleCache here\n      // if state.isScrolling (not from _isScrolling) then reset\n\n\n      if (!this.state.isScrolling) {\n        this._resetStyleCache();\n      } // calculate children to render here\n\n\n      this._calculateChildrenToRender(this.props, this.state);\n\n      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n      var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize(); // Force browser to hide scrollbars when we know they aren't necessary.\n      // Otherwise once scrollbars appear they may not disappear again.\n      // For more info see issue #116\n\n      var verticalScrollBarSize = totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\n      var horizontalScrollBarSize = totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\n\n      if (horizontalScrollBarSize !== this._horizontalScrollBarSize || verticalScrollBarSize !== this._verticalScrollBarSize) {\n        this._horizontalScrollBarSize = horizontalScrollBarSize;\n        this._verticalScrollBarSize = verticalScrollBarSize;\n        this._scrollbarPresenceChanged = true;\n      } // Also explicitly init styles to 'auto' if scrollbars are required.\n      // This works around an obscure edge case where external CSS styles have not yet been loaded,\n      // But an initial scroll index of offset is set as an external prop.\n      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.\n      // This was originally reported via clauderic/react-infinite-calendar/issues/23\n\n\n      gridStyle.overflowX = totalColumnsWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';\n      gridStyle.overflowY = totalRowsHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';\n      var childrenToDisplay = this._childrenToDisplay;\n      var showNoContentRenderer = childrenToDisplay.length === 0 && height > 0 && width > 0;\n      return React.createElement('div', (0, _extends3.default)({\n        ref: this._setScrollingContainerRef\n      }, containerProps, {\n        'aria-label': this.props['aria-label'],\n        'aria-readonly': this.props['aria-readonly'],\n        className: (0, _clsx2.default)('ReactVirtualized__Grid', className),\n        id: id,\n        onScroll: this._onScroll,\n        role: role,\n        style: (0, _extends3.default)({}, gridStyle, style),\n        tabIndex: tabIndex\n      }), childrenToDisplay.length > 0 && React.createElement('div', {\n        className: 'ReactVirtualized__Grid__innerScrollContainer',\n        role: containerRole,\n        style: (0, _extends3.default)({\n          width: autoContainerWidth ? 'auto' : totalColumnsWidth,\n          height: totalRowsHeight,\n          maxWidth: totalColumnsWidth,\n          maxHeight: totalRowsHeight,\n          overflow: 'hidden',\n          pointerEvents: isScrolling ? 'none' : '',\n          position: 'relative'\n        }, containerStyle)\n      }, childrenToDisplay), showNoContentRenderer && noContentRenderer());\n    }\n    /* ---------------------------- Helper methods ---------------------------- */\n\n  }, {\n    key: '_calculateChildrenToRender',\n    value: function _calculateChildrenToRender() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      var cellRenderer = props.cellRenderer,\n          cellRangeRenderer = props.cellRangeRenderer,\n          columnCount = props.columnCount,\n          deferredMeasurementCache = props.deferredMeasurementCache,\n          height = props.height,\n          overscanColumnCount = props.overscanColumnCount,\n          overscanIndicesGetter = props.overscanIndicesGetter,\n          overscanRowCount = props.overscanRowCount,\n          rowCount = props.rowCount,\n          width = props.width,\n          isScrollingOptOut = props.isScrollingOptOut;\n      var scrollDirectionHorizontal = state.scrollDirectionHorizontal,\n          scrollDirectionVertical = state.scrollDirectionVertical,\n          instanceProps = state.instanceProps;\n      var scrollTop = this._initialScrollTop > 0 ? this._initialScrollTop : state.scrollTop;\n      var scrollLeft = this._initialScrollLeft > 0 ? this._initialScrollLeft : state.scrollLeft;\n\n      var isScrolling = this._isScrolling(props, state);\n\n      this._childrenToDisplay = []; // Render only enough columns and rows to cover the visible area of the grid.\n\n      if (height > 0 && width > 0) {\n        var visibleColumnIndices = instanceProps.columnSizeAndPositionManager.getVisibleCellRange({\n          containerSize: width,\n          offset: scrollLeft\n        });\n        var visibleRowIndices = instanceProps.rowSizeAndPositionManager.getVisibleCellRange({\n          containerSize: height,\n          offset: scrollTop\n        });\n        var horizontalOffsetAdjustment = instanceProps.columnSizeAndPositionManager.getOffsetAdjustment({\n          containerSize: width,\n          offset: scrollLeft\n        });\n        var verticalOffsetAdjustment = instanceProps.rowSizeAndPositionManager.getOffsetAdjustment({\n          containerSize: height,\n          offset: scrollTop\n        }); // Store for _invokeOnGridRenderedHelper()\n\n        this._renderedColumnStartIndex = visibleColumnIndices.start;\n        this._renderedColumnStopIndex = visibleColumnIndices.stop;\n        this._renderedRowStartIndex = visibleRowIndices.start;\n        this._renderedRowStopIndex = visibleRowIndices.stop;\n        var overscanColumnIndices = overscanIndicesGetter({\n          direction: 'horizontal',\n          cellCount: columnCount,\n          overscanCellsCount: overscanColumnCount,\n          scrollDirection: scrollDirectionHorizontal,\n          startIndex: typeof visibleColumnIndices.start === 'number' ? visibleColumnIndices.start : 0,\n          stopIndex: typeof visibleColumnIndices.stop === 'number' ? visibleColumnIndices.stop : -1\n        });\n        var overscanRowIndices = overscanIndicesGetter({\n          direction: 'vertical',\n          cellCount: rowCount,\n          overscanCellsCount: overscanRowCount,\n          scrollDirection: scrollDirectionVertical,\n          startIndex: typeof visibleRowIndices.start === 'number' ? visibleRowIndices.start : 0,\n          stopIndex: typeof visibleRowIndices.stop === 'number' ? visibleRowIndices.stop : -1\n        }); // Store for _invokeOnGridRenderedHelper()\n\n        var columnStartIndex = overscanColumnIndices.overscanStartIndex;\n        var columnStopIndex = overscanColumnIndices.overscanStopIndex;\n        var rowStartIndex = overscanRowIndices.overscanStartIndex;\n        var rowStopIndex = overscanRowIndices.overscanStopIndex; // Advanced use-cases (eg CellMeasurer) require batched measurements to determine accurate sizes.\n\n        if (deferredMeasurementCache) {\n          // If rows have a dynamic height, scan the rows we are about to render.\n          // If any have not yet been measured, then we need to render all columns initially,\n          // Because the height of the row is equal to the tallest cell within that row,\n          // (And so we can't know the height without measuring all column-cells first).\n          if (!deferredMeasurementCache.hasFixedHeight()) {\n            for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {\n              if (!deferredMeasurementCache.has(rowIndex, 0)) {\n                columnStartIndex = 0;\n                columnStopIndex = columnCount - 1;\n                break;\n              }\n            }\n          } // If columns have a dynamic width, scan the columns we are about to render.\n          // If any have not yet been measured, then we need to render all rows initially,\n          // Because the width of the column is equal to the widest cell within that column,\n          // (And so we can't know the width without measuring all row-cells first).\n\n\n          if (!deferredMeasurementCache.hasFixedWidth()) {\n            for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {\n              if (!deferredMeasurementCache.has(0, columnIndex)) {\n                rowStartIndex = 0;\n                rowStopIndex = rowCount - 1;\n                break;\n              }\n            }\n          }\n        }\n\n        this._childrenToDisplay = cellRangeRenderer({\n          cellCache: this._cellCache,\n          cellRenderer: cellRenderer,\n          columnSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\n          columnStartIndex: columnStartIndex,\n          columnStopIndex: columnStopIndex,\n          deferredMeasurementCache: deferredMeasurementCache,\n          horizontalOffsetAdjustment: horizontalOffsetAdjustment,\n          isScrolling: isScrolling,\n          isScrollingOptOut: isScrollingOptOut,\n          parent: this,\n          rowSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\n          rowStartIndex: rowStartIndex,\n          rowStopIndex: rowStopIndex,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          styleCache: this._styleCache,\n          verticalOffsetAdjustment: verticalOffsetAdjustment,\n          visibleColumnIndices: visibleColumnIndices,\n          visibleRowIndices: visibleRowIndices\n        }); // update the indices\n\n        this._columnStartIndex = columnStartIndex;\n        this._columnStopIndex = columnStopIndex;\n        this._rowStartIndex = rowStartIndex;\n        this._rowStopIndex = rowStopIndex;\n      }\n    }\n    /**\n     * Sets an :isScrolling flag for a small window of time.\n     * This flag is used to disable pointer events on the scrollable portion of the Grid.\n     * This prevents jerky/stuttery mouse-wheel scrolling.\n     */\n\n  }, {\n    key: '_debounceScrollEnded',\n    value: function _debounceScrollEnded() {\n      var scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;\n\n      if (this._disablePointerEventsTimeoutId) {\n        (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId);\n      }\n\n      this._disablePointerEventsTimeoutId = (0, _requestAnimationTimeout.requestAnimationTimeout)(this._debounceScrollEndedCallback, scrollingResetTimeInterval);\n    }\n  }, {\n    key: '_handleInvalidatedGridSize',\n\n    /**\n     * Check for batched CellMeasurer size invalidations.\n     * This will occur the first time one or more previously unmeasured cells are rendered.\n     */\n    value: function _handleInvalidatedGridSize() {\n      if (typeof this._deferredInvalidateColumnIndex === 'number' && typeof this._deferredInvalidateRowIndex === 'number') {\n        var columnIndex = this._deferredInvalidateColumnIndex;\n        var rowIndex = this._deferredInvalidateRowIndex;\n        this._deferredInvalidateColumnIndex = null;\n        this._deferredInvalidateRowIndex = null;\n        this.recomputeGridSize({\n          columnIndex: columnIndex,\n          rowIndex: rowIndex\n        });\n      }\n    }\n  }, {\n    key: '_invokeOnScrollMemoizer',\n    value: function _invokeOnScrollMemoizer(_ref6) {\n      var _this3 = this;\n\n      var scrollLeft = _ref6.scrollLeft,\n          scrollTop = _ref6.scrollTop,\n          totalColumnsWidth = _ref6.totalColumnsWidth,\n          totalRowsHeight = _ref6.totalRowsHeight;\n\n      this._onScrollMemoizer({\n        callback: function callback(_ref7) {\n          var scrollLeft = _ref7.scrollLeft,\n              scrollTop = _ref7.scrollTop;\n          var _props7 = _this3.props,\n              height = _props7.height,\n              onScroll = _props7.onScroll,\n              width = _props7.width;\n          onScroll({\n            clientHeight: height,\n            clientWidth: width,\n            scrollHeight: totalRowsHeight,\n            scrollLeft: scrollLeft,\n            scrollTop: scrollTop,\n            scrollWidth: totalColumnsWidth\n          });\n        },\n        indices: {\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        }\n      });\n    }\n  }, {\n    key: '_isScrolling',\n    value: function _isScrolling() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state; // If isScrolling is defined in props, use it to override the value in state\n      // This is a performance optimization for WindowScroller + Grid\n\n      return Object.hasOwnProperty.call(props, 'isScrolling') ? Boolean(props.isScrolling) : Boolean(state.isScrolling);\n    }\n  }, {\n    key: '_maybeCallOnScrollbarPresenceChange',\n    value: function _maybeCallOnScrollbarPresenceChange() {\n      if (this._scrollbarPresenceChanged) {\n        var _onScrollbarPresenceChange = this.props.onScrollbarPresenceChange;\n        this._scrollbarPresenceChanged = false;\n\n        _onScrollbarPresenceChange({\n          horizontal: this._horizontalScrollBarSize > 0,\n          size: this.state.instanceProps.scrollbarSize,\n          vertical: this._verticalScrollBarSize > 0\n        });\n      }\n    }\n  }, {\n    key: 'scrollToPosition',\n\n    /**\n     * Scroll to the specified offset(s).\n     * Useful for animating position changes.\n     */\n    value: function scrollToPosition(_ref8) {\n      var scrollLeft = _ref8.scrollLeft,\n          scrollTop = _ref8.scrollTop;\n\n      var stateUpdate = Grid._getScrollToPositionStateUpdate({\n        prevState: this.state,\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop\n      });\n\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }, {\n    key: '_getCalculatedScrollLeft',\n    value: function _getCalculatedScrollLeft() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      return Grid._getCalculatedScrollLeft(props, state);\n    }\n  }, {\n    key: '_updateScrollLeftForScrollToColumn',\n    value: function _updateScrollLeftForScrollToColumn() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      var stateUpdate = Grid._getScrollLeftForScrollToColumnStateUpdate(props, state);\n\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }, {\n    key: '_getCalculatedScrollTop',\n    value: function _getCalculatedScrollTop() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      return Grid._getCalculatedScrollTop(props, state);\n    }\n  }, {\n    key: '_resetStyleCache',\n    value: function _resetStyleCache() {\n      var styleCache = this._styleCache;\n      var cellCache = this._cellCache;\n      var isScrollingOptOut = this.props.isScrollingOptOut; // Reset cell and style caches once scrolling stops.\n      // This makes Grid simpler to use (since cells commonly change).\n      // And it keeps the caches from growing too large.\n      // Performance is most sensitive when a user is scrolling.\n      // Don't clear visible cells from cellCache if isScrollingOptOut is specified.\n      // This keeps the cellCache to a resonable size.\n\n      this._cellCache = {};\n      this._styleCache = {}; // Copy over the visible cell styles so avoid unnecessary re-render.\n\n      for (var rowIndex = this._rowStartIndex; rowIndex <= this._rowStopIndex; rowIndex++) {\n        for (var columnIndex = this._columnStartIndex; columnIndex <= this._columnStopIndex; columnIndex++) {\n          var key = rowIndex + '-' + columnIndex;\n          this._styleCache[key] = styleCache[key];\n\n          if (isScrollingOptOut) {\n            this._cellCache[key] = cellCache[key];\n          }\n        }\n      }\n    }\n  }, {\n    key: '_updateScrollTopForScrollToRow',\n    value: function _updateScrollTopForScrollToRow() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      var stateUpdate = Grid._getScrollTopForScrollToRowStateUpdate(props, state);\n\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }], [{\n    key: 'getDerivedStateFromProps',\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var newState = {};\n\n      if (nextProps.columnCount === 0 && prevState.scrollLeft !== 0 || nextProps.rowCount === 0 && prevState.scrollTop !== 0) {\n        newState.scrollLeft = 0;\n        newState.scrollTop = 0; // only use scroll{Left,Top} from props if scrollTo{Column,Row} isn't specified\n        // scrollTo{Column,Row} should override scroll{Left,Top}\n      } else if (nextProps.scrollLeft !== prevState.scrollLeft && nextProps.scrollToColumn < 0 || nextProps.scrollTop !== prevState.scrollTop && nextProps.scrollToRow < 0) {\n        (0, _assign2.default)(newState, Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: nextProps.scrollLeft,\n          scrollTop: nextProps.scrollTop\n        }));\n      }\n\n      var instanceProps = prevState.instanceProps; // Initially we should not clearStyleCache\n\n      newState.needToResetStyleCache = false;\n\n      if (nextProps.columnWidth !== instanceProps.prevColumnWidth || nextProps.rowHeight !== instanceProps.prevRowHeight) {\n        // Reset cache. set it to {} in render\n        newState.needToResetStyleCache = true;\n      }\n\n      instanceProps.columnSizeAndPositionManager.configure({\n        cellCount: nextProps.columnCount,\n        estimatedCellSize: Grid._getEstimatedColumnSize(nextProps),\n        cellSizeGetter: Grid._wrapSizeGetter(nextProps.columnWidth)\n      });\n      instanceProps.rowSizeAndPositionManager.configure({\n        cellCount: nextProps.rowCount,\n        estimatedCellSize: Grid._getEstimatedRowSize(nextProps),\n        cellSizeGetter: Grid._wrapSizeGetter(nextProps.rowHeight)\n      });\n\n      if (instanceProps.prevColumnCount === 0 || instanceProps.prevRowCount === 0) {\n        instanceProps.prevColumnCount = 0;\n        instanceProps.prevRowCount = 0;\n      } // If scrolling is controlled outside this component, clear cache when scrolling stops\n\n\n      if (nextProps.autoHeight && nextProps.isScrolling === false && instanceProps.prevIsScrolling === true) {\n        (0, _assign2.default)(newState, {\n          isScrolling: false\n        });\n      }\n\n      var maybeStateA = void 0;\n      var maybeStateB = void 0;\n      (0, _calculateSizeAndPositionDataAndUpdateScrollOffset2.default)({\n        cellCount: instanceProps.prevColumnCount,\n        cellSize: typeof instanceProps.prevColumnWidth === 'number' ? instanceProps.prevColumnWidth : null,\n        computeMetadataCallback: function computeMetadataCallback() {\n          return instanceProps.columnSizeAndPositionManager.resetCell(0);\n        },\n        computeMetadataCallbackProps: nextProps,\n        nextCellsCount: nextProps.columnCount,\n        nextCellSize: typeof nextProps.columnWidth === 'number' ? nextProps.columnWidth : null,\n        nextScrollToIndex: nextProps.scrollToColumn,\n        scrollToIndex: instanceProps.prevScrollToColumn,\n        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {\n          maybeStateA = Grid._getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState);\n        }\n      });\n      (0, _calculateSizeAndPositionDataAndUpdateScrollOffset2.default)({\n        cellCount: instanceProps.prevRowCount,\n        cellSize: typeof instanceProps.prevRowHeight === 'number' ? instanceProps.prevRowHeight : null,\n        computeMetadataCallback: function computeMetadataCallback() {\n          return instanceProps.rowSizeAndPositionManager.resetCell(0);\n        },\n        computeMetadataCallbackProps: nextProps,\n        nextCellsCount: nextProps.rowCount,\n        nextCellSize: typeof nextProps.rowHeight === 'number' ? nextProps.rowHeight : null,\n        nextScrollToIndex: nextProps.scrollToRow,\n        scrollToIndex: instanceProps.prevScrollToRow,\n        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {\n          maybeStateB = Grid._getScrollTopForScrollToRowStateUpdate(nextProps, prevState);\n        }\n      });\n      instanceProps.prevColumnCount = nextProps.columnCount;\n      instanceProps.prevColumnWidth = nextProps.columnWidth;\n      instanceProps.prevIsScrolling = nextProps.isScrolling === true;\n      instanceProps.prevRowCount = nextProps.rowCount;\n      instanceProps.prevRowHeight = nextProps.rowHeight;\n      instanceProps.prevScrollToColumn = nextProps.scrollToColumn;\n      instanceProps.prevScrollToRow = nextProps.scrollToRow; // getting scrollBarSize (moved from componentWillMount)\n\n      instanceProps.scrollbarSize = nextProps.getScrollbarSize();\n\n      if (instanceProps.scrollbarSize === undefined) {\n        instanceProps.scrollbarSizeMeasured = false;\n        instanceProps.scrollbarSize = 0;\n      } else {\n        instanceProps.scrollbarSizeMeasured = true;\n      }\n\n      newState.instanceProps = instanceProps;\n      return (0, _extends3.default)({}, newState, maybeStateA, maybeStateB);\n    }\n  }, {\n    key: '_getEstimatedColumnSize',\n    value: function _getEstimatedColumnSize(props) {\n      return typeof props.columnWidth === 'number' ? props.columnWidth : props.estimatedColumnSize;\n    }\n  }, {\n    key: '_getEstimatedRowSize',\n    value: function _getEstimatedRowSize(props) {\n      return typeof props.rowHeight === 'number' ? props.rowHeight : props.estimatedRowSize;\n    }\n  }, {\n    key: '_getScrollToPositionStateUpdate',\n\n    /**\n     * Get the updated state after scrolling to\n     * scrollLeft and scrollTop\n     */\n    value: function _getScrollToPositionStateUpdate(_ref9) {\n      var prevState = _ref9.prevState,\n          scrollLeft = _ref9.scrollLeft,\n          scrollTop = _ref9.scrollTop;\n      var newState = {\n        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n      };\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0) {\n        newState.scrollDirectionHorizontal = scrollLeft > prevState.scrollLeft ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD;\n        newState.scrollLeft = scrollLeft;\n      }\n\n      if (typeof scrollTop === 'number' && scrollTop >= 0) {\n        newState.scrollDirectionVertical = scrollTop > prevState.scrollTop ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD;\n        newState.scrollTop = scrollTop;\n      }\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft || typeof scrollTop === 'number' && scrollTop >= 0 && scrollTop !== prevState.scrollTop) {\n        return newState;\n      }\n\n      return null;\n    }\n  }, {\n    key: '_wrapSizeGetter',\n    value: function _wrapSizeGetter(value) {\n      return typeof value === 'function' ? value : function () {\n        return value;\n      };\n    }\n  }, {\n    key: '_getCalculatedScrollLeft',\n    value: function _getCalculatedScrollLeft(nextProps, prevState) {\n      var columnCount = nextProps.columnCount,\n          height = nextProps.height,\n          scrollToAlignment = nextProps.scrollToAlignment,\n          scrollToColumn = nextProps.scrollToColumn,\n          width = nextProps.width;\n      var scrollLeft = prevState.scrollLeft,\n          instanceProps = prevState.instanceProps;\n\n      if (columnCount > 0) {\n        var finalColumn = columnCount - 1;\n        var targetIndex = scrollToColumn < 0 ? finalColumn : Math.min(finalColumn, scrollToColumn);\n        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n        var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\n        return instanceProps.columnSizeAndPositionManager.getUpdatedOffsetForIndex({\n          align: scrollToAlignment,\n          containerSize: width - scrollBarSize,\n          currentOffset: scrollLeft,\n          targetIndex: targetIndex\n        });\n      }\n\n      return 0;\n    }\n  }, {\n    key: '_getScrollLeftForScrollToColumnStateUpdate',\n    value: function _getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState) {\n      var scrollLeft = prevState.scrollLeft;\n\n      var calculatedScrollLeft = Grid._getCalculatedScrollLeft(nextProps, prevState);\n\n      if (typeof calculatedScrollLeft === 'number' && calculatedScrollLeft >= 0 && scrollLeft !== calculatedScrollLeft) {\n        return Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: calculatedScrollLeft,\n          scrollTop: -1\n        });\n      }\n\n      return null;\n    }\n  }, {\n    key: '_getCalculatedScrollTop',\n    value: function _getCalculatedScrollTop(nextProps, prevState) {\n      var height = nextProps.height,\n          rowCount = nextProps.rowCount,\n          scrollToAlignment = nextProps.scrollToAlignment,\n          scrollToRow = nextProps.scrollToRow,\n          width = nextProps.width;\n      var scrollTop = prevState.scrollTop,\n          instanceProps = prevState.instanceProps;\n\n      if (rowCount > 0) {\n        var finalRow = rowCount - 1;\n        var targetIndex = scrollToRow < 0 ? finalRow : Math.min(finalRow, scrollToRow);\n        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n        var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\n        return instanceProps.rowSizeAndPositionManager.getUpdatedOffsetForIndex({\n          align: scrollToAlignment,\n          containerSize: height - scrollBarSize,\n          currentOffset: scrollTop,\n          targetIndex: targetIndex\n        });\n      }\n\n      return 0;\n    }\n  }, {\n    key: '_getScrollTopForScrollToRowStateUpdate',\n    value: function _getScrollTopForScrollToRowStateUpdate(nextProps, prevState) {\n      var scrollTop = prevState.scrollTop;\n\n      var calculatedScrollTop = Grid._getCalculatedScrollTop(nextProps, prevState);\n\n      if (typeof calculatedScrollTop === 'number' && calculatedScrollTop >= 0 && scrollTop !== calculatedScrollTop) {\n        return Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: -1,\n          scrollTop: calculatedScrollTop\n        });\n      }\n\n      return null;\n    }\n  }]);\n  return Grid;\n}(React.PureComponent);\n\nGrid.defaultProps = {\n  'aria-label': 'grid',\n  'aria-readonly': true,\n  autoContainerWidth: false,\n  autoHeight: false,\n  autoWidth: false,\n  cellRangeRenderer: _defaultCellRangeRenderer2.default,\n  containerRole: 'rowgroup',\n  containerStyle: {},\n  estimatedColumnSize: 100,\n  estimatedRowSize: 30,\n  getScrollbarSize: _scrollbarSize2.default,\n  noContentRenderer: renderNull,\n  onScroll: function onScroll() {},\n  onScrollbarPresenceChange: function onScrollbarPresenceChange() {},\n  onSectionRendered: function onSectionRendered() {},\n  overscanColumnCount: 0,\n  overscanIndicesGetter: _defaultOverscanIndicesGetter2.default,\n  overscanRowCount: 10,\n  role: 'grid',\n  scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL,\n  scrollToAlignment: 'auto',\n  scrollToColumn: -1,\n  scrollToRow: -1,\n  style: {},\n  tabIndex: 0,\n  isScrollingOptOut: false\n};\nGrid.propTypes = process.env.NODE_ENV === 'production' ? null : {\n  \"aria-label\": _propTypes2.default.string.isRequired,\n  \"aria-readonly\": _propTypes2.default.bool,\n\n  /**\n   * Set the width of the inner scrollable container to 'auto'.\n   * This is useful for single-column Grids to ensure that the column doesn't extend below a vertical scrollbar.\n   */\n  autoContainerWidth: _propTypes2.default.bool.isRequired,\n\n  /**\n   * Removes fixed height from the scrollingContainer so that the total height of rows can stretch the window.\n   * Intended for use with WindowScroller\n   */\n  autoHeight: _propTypes2.default.bool.isRequired,\n\n  /**\n   * Removes fixed width from the scrollingContainer so that the total width of rows can stretch the window.\n   * Intended for use with WindowScroller\n   */\n  autoWidth: _propTypes2.default.bool.isRequired,\n\n  /** Responsible for rendering a cell given an row and column index.  */\n  cellRenderer: function cellRenderer() {\n    return (typeof _types.bpfrpt_proptype_CellRenderer === 'function' ? _types.bpfrpt_proptype_CellRenderer.isRequired ? _types.bpfrpt_proptype_CellRenderer.isRequired : _types.bpfrpt_proptype_CellRenderer : _propTypes2.default.shape(_types.bpfrpt_proptype_CellRenderer).isRequired).apply(this, arguments);\n  },\n\n  /** Responsible for rendering a group of cells given their index ranges.  */\n  cellRangeRenderer: function cellRangeRenderer() {\n    return (typeof _types.bpfrpt_proptype_CellRangeRenderer === 'function' ? _types.bpfrpt_proptype_CellRangeRenderer.isRequired ? _types.bpfrpt_proptype_CellRangeRenderer.isRequired : _types.bpfrpt_proptype_CellRangeRenderer : _propTypes2.default.shape(_types.bpfrpt_proptype_CellRangeRenderer).isRequired).apply(this, arguments);\n  },\n\n  /** Optional custom CSS class name to attach to root Grid element.  */\n  className: _propTypes2.default.string,\n\n  /** Number of columns in grid.  */\n  columnCount: _propTypes2.default.number.isRequired,\n\n  /** Either a fixed column width (number) or a function that returns the width of a column given its index.  */\n  columnWidth: function columnWidth() {\n    return (typeof _types.bpfrpt_proptype_CellSize === 'function' ? _types.bpfrpt_proptype_CellSize.isRequired ? _types.bpfrpt_proptype_CellSize.isRequired : _types.bpfrpt_proptype_CellSize : _propTypes2.default.shape(_types.bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);\n  },\n\n  /** Unfiltered props for the Grid container. */\n  containerProps: _propTypes2.default.object,\n\n  /** ARIA role for the cell-container.  */\n  containerRole: _propTypes2.default.string.isRequired,\n\n  /** Optional inline style applied to inner cell-container */\n  containerStyle: _propTypes2.default.object.isRequired,\n\n  /**\n   * If CellMeasurer is used to measure this Grid's children, this should be a pointer to its CellMeasurerCache.\n   * A shared CellMeasurerCache reference enables Grid and CellMeasurer to share measurement data.\n   */\n  deferredMeasurementCache: _propTypes2.default.object,\n\n  /**\n   * Used to estimate the total width of a Grid before all of its columns have actually been measured.\n   * The estimated total width is adjusted as columns are rendered.\n   */\n  estimatedColumnSize: _propTypes2.default.number.isRequired,\n\n  /**\n   * Used to estimate the total height of a Grid before all of its rows have actually been measured.\n   * The estimated total height is adjusted as rows are rendered.\n   */\n  estimatedRowSize: _propTypes2.default.number.isRequired,\n\n  /** Exposed for testing purposes only.  */\n  getScrollbarSize: _propTypes2.default.func.isRequired,\n\n  /** Height of Grid; this property determines the number of visible (vs virtualized) rows.  */\n  height: _propTypes2.default.number.isRequired,\n\n  /** Optional custom id to attach to root Grid element.  */\n  id: _propTypes2.default.string,\n\n  /**\n   * Override internal is-scrolling state tracking.\n   * This property is primarily intended for use with the WindowScroller component.\n   */\n  isScrolling: _propTypes2.default.bool,\n\n  /**\n   * Opt-out of isScrolling param passed to cellRangeRenderer.\n   * To avoid the extra render when scroll stops.\n   */\n  isScrollingOptOut: _propTypes2.default.bool.isRequired,\n\n  /** Optional renderer to be used in place of rows when either :rowCount or :columnCount is 0.  */\n  noContentRenderer: function noContentRenderer() {\n    return (typeof _types.bpfrpt_proptype_NoContentRenderer === 'function' ? _types.bpfrpt_proptype_NoContentRenderer.isRequired ? _types.bpfrpt_proptype_NoContentRenderer.isRequired : _types.bpfrpt_proptype_NoContentRenderer : _propTypes2.default.shape(_types.bpfrpt_proptype_NoContentRenderer).isRequired).apply(this, arguments);\n  },\n\n  /**\n   * Callback invoked whenever the scroll offset changes within the inner scrollable region.\n   * This callback can be used to sync scrolling between lists, tables, or grids.\n   */\n  onScroll: _propTypes2.default.func.isRequired,\n\n  /**\n   * Called whenever a horizontal or vertical scrollbar is added or removed.\n   * This prop is not intended for end-user use;\n   * It is used by MultiGrid to support fixed-row/fixed-column scroll syncing.\n   */\n  onScrollbarPresenceChange: _propTypes2.default.func.isRequired,\n\n  /** Callback invoked with information about the section of the Grid that was just rendered.  */\n  onSectionRendered: _propTypes2.default.func.isRequired,\n\n  /**\n   * Number of columns to render before/after the visible section of the grid.\n   * These columns can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.\n   */\n  overscanColumnCount: _propTypes2.default.number.isRequired,\n\n  /**\n   * Calculates the number of cells to overscan before and after a specified range.\n   * This function ensures that overscanning doesn't exceed the available cells.\n   */\n  overscanIndicesGetter: function overscanIndicesGetter() {\n    return (typeof _types.bpfrpt_proptype_OverscanIndicesGetter === 'function' ? _types.bpfrpt_proptype_OverscanIndicesGetter.isRequired ? _types.bpfrpt_proptype_OverscanIndicesGetter.isRequired : _types.bpfrpt_proptype_OverscanIndicesGetter : _propTypes2.default.shape(_types.bpfrpt_proptype_OverscanIndicesGetter).isRequired).apply(this, arguments);\n  },\n\n  /**\n   * Number of rows to render above/below the visible section of the grid.\n   * These rows can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.\n   */\n  overscanRowCount: _propTypes2.default.number.isRequired,\n\n  /** ARIA role for the grid element.  */\n  role: _propTypes2.default.string.isRequired,\n\n  /**\n   * Either a fixed row height (number) or a function that returns the height of a row given its index.\n   * Should implement the following interface: ({ index: number }): number\n   */\n  rowHeight: function rowHeight() {\n    return (typeof _types.bpfrpt_proptype_CellSize === 'function' ? _types.bpfrpt_proptype_CellSize.isRequired ? _types.bpfrpt_proptype_CellSize.isRequired : _types.bpfrpt_proptype_CellSize : _propTypes2.default.shape(_types.bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);\n  },\n\n  /** Number of rows in grid.  */\n  rowCount: _propTypes2.default.number.isRequired,\n\n  /** Wait this amount of time after the last scroll event before resetting Grid `pointer-events`. */\n  scrollingResetTimeInterval: _propTypes2.default.number.isRequired,\n\n  /** Horizontal offset. */\n  scrollLeft: _propTypes2.default.number,\n\n  /**\n   * Controls scroll-to-cell behavior of the Grid.\n   * The default (\"auto\") scrolls the least amount possible to ensure that the specified cell is fully visible.\n   * Use \"start\" to align cells to the top/left of the Grid and \"end\" to align bottom/right.\n   */\n  scrollToAlignment: function scrollToAlignment() {\n    return (typeof _types.bpfrpt_proptype_Alignment === 'function' ? _types.bpfrpt_proptype_Alignment.isRequired ? _types.bpfrpt_proptype_Alignment.isRequired : _types.bpfrpt_proptype_Alignment : _propTypes2.default.shape(_types.bpfrpt_proptype_Alignment).isRequired).apply(this, arguments);\n  },\n\n  /** Column index to ensure visible (by forcefully scrolling if necessary) */\n  scrollToColumn: _propTypes2.default.number.isRequired,\n\n  /** Vertical offset. */\n  scrollTop: _propTypes2.default.number,\n\n  /** Row index to ensure visible (by forcefully scrolling if necessary) */\n  scrollToRow: _propTypes2.default.number.isRequired,\n\n  /** Optional inline style */\n  style: _propTypes2.default.object.isRequired,\n\n  /** Tab index for focus */\n  tabIndex: _propTypes2.default.number,\n\n  /** Width of Grid; this property determines the number of visible (vs virtualized) columns.  */\n  width: _propTypes2.default.number.isRequired\n};\n(0, _reactLifecyclesCompat.polyfill)(Grid);\nexports.default = Grid;","map":{"version":3,"sources":["/mnt/c/Users/Dell/Desktop/KhanaWeb/khanaweb/node_modules/react-virtualized/dist/commonjs/Grid/Grid.js"],"names":["Object","defineProperty","exports","value","DEFAULT_SCROLLING_RESET_TIME_INTERVAL","undefined","_assign","require","_assign2","_interopRequireDefault","_extends2","_extends3","_getPrototypeOf","_getPrototypeOf2","_classCallCheck2","_classCallCheck3","_createClass2","_createClass3","_possibleConstructorReturn2","_possibleConstructorReturn3","_inherits2","_inherits3","_react","React","_interopRequireWildcard","_clsx","_clsx2","_calculateSizeAndPositionDataAndUpdateScrollOffset","_calculateSizeAndPositionDataAndUpdateScrollOffset2","_ScalingCellSizeAndPositionManager","_ScalingCellSizeAndPositionManager2","_createCallbackMemoizer","_createCallbackMemoizer2","_defaultOverscanIndicesGetter","_defaultOverscanIndicesGetter2","_updateScrollIndexHelper","_updateScrollIndexHelper2","_defaultCellRangeRenderer","_defaultCellRangeRenderer2","_scrollbarSize","_scrollbarSize2","_reactLifecyclesCompat","_requestAnimationTimeout","_types","_propTypes","_propTypes2","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","default","SCROLL_POSITION_CHANGE_REASONS","OBSERVED","REQUESTED","renderNull","Grid","_React$PureComponent","props","_this","__proto__","_onGridRenderedMemoizer","_onScrollMemoizer","_deferredInvalidateColumnIndex","_deferredInvalidateRowIndex","_recomputeScrollLeftFlag","_recomputeScrollTopFlag","_horizontalScrollBarSize","_verticalScrollBarSize","_scrollbarPresenceChanged","_renderedColumnStartIndex","_renderedColumnStopIndex","_renderedRowStartIndex","_renderedRowStopIndex","_styleCache","_cellCache","_debounceScrollEndedCallback","_disablePointerEventsTimeoutId","setState","isScrolling","needToResetStyleCache","_invokeOnGridRenderedHelper","onSectionRendered","callback","indices","columnOverscanStartIndex","_columnStartIndex","columnOverscanStopIndex","_columnStopIndex","columnStartIndex","columnStopIndex","rowOverscanStartIndex","_rowStartIndex","rowOverscanStopIndex","_rowStopIndex","rowStartIndex","rowStopIndex","_setScrollingContainerRef","ref","_scrollingContainer","_onScroll","event","target","handleScrollEvent","columnSizeAndPositionManager","cellCount","columnCount","cellSizeGetter","params","_wrapSizeGetter","columnWidth","estimatedCellSize","_getEstimatedColumnSize","rowSizeAndPositionManager","rowCount","rowHeight","_getEstimatedRowSize","state","instanceProps","prevColumnWidth","prevRowHeight","prevColumnCount","prevRowCount","prevIsScrolling","prevScrollToColumn","scrollToColumn","prevScrollToRow","scrollToRow","scrollbarSize","scrollbarSizeMeasured","scrollDirectionHorizontal","SCROLL_DIRECTION_FORWARD","scrollDirectionVertical","scrollLeft","scrollTop","scrollPositionChangeReason","_initialScrollTop","_getCalculatedScrollTop","_initialScrollLeft","_getCalculatedScrollLeft","getOffsetForCell","_ref","arguments","length","_ref$alignment","alignment","scrollToAlignment","_ref$columnIndex","columnIndex","_ref$rowIndex","rowIndex","offsetProps","getTotalRowsHeight","getTotalSize","getTotalColumnsWidth","_ref2","_ref2$scrollLeft","scrollLeftParam","_ref2$scrollTop","scrollTopParam","_debounceScrollEnded","_props","autoHeight","autoWidth","height","width","totalRowsHeight","totalColumnsWidth","Math","min","max","_scrollDirectionHorizontal","SCROLL_DIRECTION_BACKWARD","_scrollDirectionVertical","newState","_invokeOnScrollMemoizer","invalidateCellSizeAfterRender","_ref3","measureAllCells","_props2","getSizeAndPositionOfCell","recomputeGridSize","_ref4","_ref4$columnIndex","_ref4$rowIndex","_props3","resetCell","forceUpdate","scrollToCell","_ref5","_updateScrollLeftForScrollToColumn","_updateScrollTopForScrollToRow","componentDidMount","_props4","getScrollbarSize","_handleInvalidatedGridSize","prevState","stateUpdate","_getScrollToPositionStateUpdate","sizeIsBiggerThanZero","_maybeCallOnScrollbarPresenceChange","componentDidUpdate","prevProps","_this2","_props5","_state","columnOrRowCountJustIncreasedFromZero","sizeJustIncreasedFromZero","cellSizeAndPositionManager","previousCellsCount","previousCellSize","previousScrollToAlignment","previousScrollToIndex","previousSize","scrollOffset","scrollToIndex","size","updateScrollIndexCallback","componentWillUnmount","cancelAnimationTimeout","render","_props6","autoContainerWidth","className","containerProps","containerRole","containerStyle","id","noContentRenderer","role","style","tabIndex","_state2","_isScrolling","gridStyle","boxSizing","direction","position","WebkitOverflowScrolling","willChange","_resetStyleCache","_calculateChildrenToRender","verticalScrollBarSize","horizontalScrollBarSize","overflowX","overflowY","childrenToDisplay","_childrenToDisplay","showNoContentRenderer","createElement","onScroll","maxWidth","maxHeight","overflow","pointerEvents","cellRenderer","cellRangeRenderer","deferredMeasurementCache","overscanColumnCount","overscanIndicesGetter","overscanRowCount","isScrollingOptOut","visibleColumnIndices","getVisibleCellRange","containerSize","offset","visibleRowIndices","horizontalOffsetAdjustment","getOffsetAdjustment","verticalOffsetAdjustment","start","stop","overscanColumnIndices","overscanCellsCount","scrollDirection","startIndex","stopIndex","overscanRowIndices","overscanStartIndex","overscanStopIndex","hasFixedHeight","has","hasFixedWidth","cellCache","parent","styleCache","scrollingResetTimeInterval","requestAnimationTimeout","_ref6","_this3","_ref7","_props7","clientHeight","clientWidth","scrollHeight","scrollWidth","Boolean","_onScrollbarPresenceChange","onScrollbarPresenceChange","horizontal","vertical","scrollToPosition","_ref8","_getScrollLeftForScrollToColumnStateUpdate","_getScrollTopForScrollToRowStateUpdate","getDerivedStateFromProps","nextProps","configure","maybeStateA","maybeStateB","cellSize","computeMetadataCallback","computeMetadataCallbackProps","nextCellsCount","nextCellSize","nextScrollToIndex","updateScrollOffsetForScrollToIndex","estimatedColumnSize","estimatedRowSize","_ref9","finalColumn","targetIndex","scrollBarSize","getUpdatedOffsetForIndex","align","currentOffset","calculatedScrollLeft","finalRow","calculatedScrollTop","PureComponent","defaultProps","propTypes","process","env","NODE_ENV","string","isRequired","bool","bpfrpt_proptype_CellRenderer","shape","apply","bpfrpt_proptype_CellRangeRenderer","number","bpfrpt_proptype_CellSize","object","func","bpfrpt_proptype_NoContentRenderer","bpfrpt_proptype_OverscanIndicesGetter","bpfrpt_proptype_Alignment","polyfill"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,qCAAR,GAAgDC,SAAhD;;AAEA,IAAIC,OAAO,GAAGC,OAAO,CAAC,qCAAD,CAArB;;AAEA,IAAIC,QAAQ,GAAGC,sBAAsB,CAACH,OAAD,CAArC;;AAEA,IAAII,SAAS,GAAGH,OAAO,CAAC,+BAAD,CAAvB;;AAEA,IAAII,SAAS,GAAGF,sBAAsB,CAACC,SAAD,CAAtC;;AAEA,IAAIE,eAAe,GAAGL,OAAO,CAAC,+CAAD,CAA7B;;AAEA,IAAIM,gBAAgB,GAAGJ,sBAAsB,CAACG,eAAD,CAA7C;;AAEA,IAAIE,gBAAgB,GAAGP,OAAO,CAAC,sCAAD,CAA9B;;AAEA,IAAIQ,gBAAgB,GAAGN,sBAAsB,CAACK,gBAAD,CAA7C;;AAEA,IAAIE,aAAa,GAAGT,OAAO,CAAC,mCAAD,CAA3B;;AAEA,IAAIU,aAAa,GAAGR,sBAAsB,CAACO,aAAD,CAA1C;;AAEA,IAAIE,2BAA2B,GAAGX,OAAO,CAAC,iDAAD,CAAzC;;AAEA,IAAIY,2BAA2B,GAAGV,sBAAsB,CAACS,2BAAD,CAAxD;;AAEA,IAAIE,UAAU,GAAGb,OAAO,CAAC,gCAAD,CAAxB;;AAEA,IAAIc,UAAU,GAAGZ,sBAAsB,CAACW,UAAD,CAAvC;;AAEA,IAAIE,MAAM,GAAGf,OAAO,CAAC,OAAD,CAApB;;AAEA,IAAIgB,KAAK,GAAGC,uBAAuB,CAACF,MAAD,CAAnC;;AAEA,IAAIG,KAAK,GAAGlB,OAAO,CAAC,MAAD,CAAnB;;AAEA,IAAImB,MAAM,GAAGjB,sBAAsB,CAACgB,KAAD,CAAnC;;AAEA,IAAIE,kDAAkD,GAAGpB,OAAO,CAAC,2DAAD,CAAhE;;AAEA,IAAIqB,mDAAmD,GAAGnB,sBAAsB,CAACkB,kDAAD,CAAhF;;AAEA,IAAIE,kCAAkC,GAAGtB,OAAO,CAAC,2CAAD,CAAhD;;AAEA,IAAIuB,mCAAmC,GAAGrB,sBAAsB,CAACoB,kCAAD,CAAhE;;AAEA,IAAIE,uBAAuB,GAAGxB,OAAO,CAAC,iCAAD,CAArC;;AAEA,IAAIyB,wBAAwB,GAAGvB,sBAAsB,CAACsB,uBAAD,CAArD;;AAEA,IAAIE,6BAA6B,GAAG1B,OAAO,CAAC,gCAAD,CAA3C;;AAEA,IAAI2B,8BAA8B,GAAGzB,sBAAsB,CAACwB,6BAAD,CAA3D;;AAEA,IAAIE,wBAAwB,GAAG5B,OAAO,CAAC,iCAAD,CAAtC;;AAEA,IAAI6B,yBAAyB,GAAG3B,sBAAsB,CAAC0B,wBAAD,CAAtD;;AAEA,IAAIE,yBAAyB,GAAG9B,OAAO,CAAC,4BAAD,CAAvC;;AAEA,IAAI+B,0BAA0B,GAAG7B,sBAAsB,CAAC4B,yBAAD,CAAvD;;AAEA,IAAIE,cAAc,GAAGhC,OAAO,CAAC,2BAAD,CAA5B;;AAEA,IAAIiC,eAAe,GAAG/B,sBAAsB,CAAC8B,cAAD,CAA5C;;AAEA,IAAIE,sBAAsB,GAAGlC,OAAO,CAAC,yBAAD,CAApC;;AAEA,IAAImC,wBAAwB,GAAGnC,OAAO,CAAC,kCAAD,CAAtC;;AAEA,IAAIoC,MAAM,GAAGpC,OAAO,CAAC,SAAD,CAApB;;AAEA,IAAIqC,UAAU,GAAGrC,OAAO,CAAC,YAAD,CAAxB;;AAEA,IAAIsC,WAAW,GAAGpC,sBAAsB,CAACmC,UAAD,CAAxC;;AAEA,SAASpB,uBAAT,CAAiCsB,GAAjC,EAAsC;AAAE,MAAIA,GAAG,IAAIA,GAAG,CAACC,UAAf,EAA2B;AAAE,WAAOD,GAAP;AAAa,GAA1C,MAAgD;AAAE,QAAIE,MAAM,GAAG,EAAb;;AAAiB,QAAIF,GAAG,IAAI,IAAX,EAAiB;AAAE,WAAK,IAAIG,GAAT,IAAgBH,GAAhB,EAAqB;AAAE,YAAI9C,MAAM,CAACkD,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCN,GAArC,EAA0CG,GAA1C,CAAJ,EAAoDD,MAAM,CAACC,GAAD,CAAN,GAAcH,GAAG,CAACG,GAAD,CAAjB;AAAyB;AAAE;;AAACD,IAAAA,MAAM,CAACK,OAAP,GAAiBP,GAAjB;AAAsB,WAAOE,MAAP;AAAgB;AAAE;;AAE7Q,SAASvC,sBAAT,CAAgCqC,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAAEO,IAAAA,OAAO,EAAEP;AAAX,GAArC;AAAwD;AAE/F;;;;;;AAIA,IAAI1C,qCAAqC,GAAGF,OAAO,CAACE,qCAAR,GAAgD,GAA5F;AAEA;;;;;AAMA,IAAIkD,8BAA8B,GAAG;AACnCC,EAAAA,QAAQ,EAAE,UADyB;AAEnCC,EAAAA,SAAS,EAAE;AAFwB,CAArC;;AAKA,IAAIC,UAAU,GAAG,SAASA,UAAT,GAAsB;AACrC,SAAO,IAAP;AACD,CAFD;AAIA;;;;;;AAIA,IAAIC,IAAI,GAAG,UAAUC,oBAAV,EAAgC;AACzC,GAAC,GAAGtC,UAAU,CAACgC,OAAf,EAAwBK,IAAxB,EAA8BC,oBAA9B,EADyC,CAGzC;;AACA,WAASD,IAAT,CAAcE,KAAd,EAAqB;AACnB,KAAC,GAAG7C,gBAAgB,CAACsC,OAArB,EAA8B,IAA9B,EAAoCK,IAApC;;AAEA,QAAIG,KAAK,GAAG,CAAC,GAAG1C,2BAA2B,CAACkC,OAAhC,EAAyC,IAAzC,EAA+C,CAACK,IAAI,CAACI,SAAL,IAAkB,CAAC,GAAGjD,gBAAgB,CAACwC,OAArB,EAA8BK,IAA9B,CAAnB,EAAwDN,IAAxD,CAA6D,IAA7D,EAAmEQ,KAAnE,CAA/C,CAAZ;;AAEAC,IAAAA,KAAK,CAACE,uBAAN,GAAgC,CAAC,GAAG/B,wBAAwB,CAACqB,OAA7B,GAAhC;AACAQ,IAAAA,KAAK,CAACG,iBAAN,GAA0B,CAAC,GAAGhC,wBAAwB,CAACqB,OAA7B,EAAsC,KAAtC,CAA1B;AACAQ,IAAAA,KAAK,CAACI,8BAAN,GAAuC,IAAvC;AACAJ,IAAAA,KAAK,CAACK,2BAAN,GAAoC,IAApC;AACAL,IAAAA,KAAK,CAACM,wBAAN,GAAiC,KAAjC;AACAN,IAAAA,KAAK,CAACO,uBAAN,GAAgC,KAAhC;AACAP,IAAAA,KAAK,CAACQ,wBAAN,GAAiC,CAAjC;AACAR,IAAAA,KAAK,CAACS,sBAAN,GAA+B,CAA/B;AACAT,IAAAA,KAAK,CAACU,yBAAN,GAAkC,KAAlC;AACAV,IAAAA,KAAK,CAACW,yBAAN,GAAkC,CAAlC;AACAX,IAAAA,KAAK,CAACY,wBAAN,GAAiC,CAAjC;AACAZ,IAAAA,KAAK,CAACa,sBAAN,GAA+B,CAA/B;AACAb,IAAAA,KAAK,CAACc,qBAAN,GAA8B,CAA9B;AACAd,IAAAA,KAAK,CAACe,WAAN,GAAoB,EAApB;AACAf,IAAAA,KAAK,CAACgB,UAAN,GAAmB,EAAnB;;AAEAhB,IAAAA,KAAK,CAACiB,4BAAN,GAAqC,YAAY;AAC/CjB,MAAAA,KAAK,CAACkB,8BAAN,GAAuC,IAAvC,CAD+C,CAE/C;;AACAlB,MAAAA,KAAK,CAACmB,QAAN,CAAe;AACbC,QAAAA,WAAW,EAAE,KADA;AAEbC,QAAAA,qBAAqB,EAAE;AAFV,OAAf;AAID,KAPD;;AASArB,IAAAA,KAAK,CAACsB,2BAAN,GAAoC,YAAY;AAC9C,UAAIC,iBAAiB,GAAGvB,KAAK,CAACD,KAAN,CAAYwB,iBAApC;;AAGAvB,MAAAA,KAAK,CAACE,uBAAN,CAA8B;AAC5BsB,QAAAA,QAAQ,EAAED,iBADkB;AAE5BE,QAAAA,OAAO,EAAE;AACPC,UAAAA,wBAAwB,EAAE1B,KAAK,CAAC2B,iBADzB;AAEPC,UAAAA,uBAAuB,EAAE5B,KAAK,CAAC6B,gBAFxB;AAGPC,UAAAA,gBAAgB,EAAE9B,KAAK,CAACW,yBAHjB;AAIPoB,UAAAA,eAAe,EAAE/B,KAAK,CAACY,wBAJhB;AAKPoB,UAAAA,qBAAqB,EAAEhC,KAAK,CAACiC,cALtB;AAMPC,UAAAA,oBAAoB,EAAElC,KAAK,CAACmC,aANrB;AAOPC,UAAAA,aAAa,EAAEpC,KAAK,CAACa,sBAPd;AAQPwB,UAAAA,YAAY,EAAErC,KAAK,CAACc;AARb;AAFmB,OAA9B;AAaD,KAjBD;;AAmBAd,IAAAA,KAAK,CAACsC,yBAAN,GAAkC,UAAUC,GAAV,EAAe;AAC/CvC,MAAAA,KAAK,CAACwC,mBAAN,GAA4BD,GAA5B;AACD,KAFD;;AAIAvC,IAAAA,KAAK,CAACyC,SAAN,GAAkB,UAAUC,KAAV,EAAiB;AACjC;AACA;AACA;AACA,UAAIA,KAAK,CAACC,MAAN,KAAiB3C,KAAK,CAACwC,mBAA3B,EAAgD;AAC9CxC,QAAAA,KAAK,CAAC4C,iBAAN,CAAwBF,KAAK,CAACC,MAA9B;AACD;AACF,KAPD;;AASA,QAAIE,4BAA4B,GAAG,IAAI5E,mCAAmC,CAACuB,OAAxC,CAAgD;AACjFsD,MAAAA,SAAS,EAAE/C,KAAK,CAACgD,WADgE;AAEjFC,MAAAA,cAAc,EAAE,SAASA,cAAT,CAAwBC,MAAxB,EAAgC;AAC9C,eAAOpD,IAAI,CAACqD,eAAL,CAAqBnD,KAAK,CAACoD,WAA3B,EAAwCF,MAAxC,CAAP;AACD,OAJgF;AAKjFG,MAAAA,iBAAiB,EAAEvD,IAAI,CAACwD,uBAAL,CAA6BtD,KAA7B;AAL8D,KAAhD,CAAnC;AAOA,QAAIuD,yBAAyB,GAAG,IAAIrF,mCAAmC,CAACuB,OAAxC,CAAgD;AAC9EsD,MAAAA,SAAS,EAAE/C,KAAK,CAACwD,QAD6D;AAE9EP,MAAAA,cAAc,EAAE,SAASA,cAAT,CAAwBC,MAAxB,EAAgC;AAC9C,eAAOpD,IAAI,CAACqD,eAAL,CAAqBnD,KAAK,CAACyD,SAA3B,EAAsCP,MAAtC,CAAP;AACD,OAJ6E;AAK9EG,MAAAA,iBAAiB,EAAEvD,IAAI,CAAC4D,oBAAL,CAA0B1D,KAA1B;AAL2D,KAAhD,CAAhC;AAQAC,IAAAA,KAAK,CAAC0D,KAAN,GAAc;AACZC,MAAAA,aAAa,EAAE;AACbd,QAAAA,4BAA4B,EAAEA,4BADjB;AAEbS,QAAAA,yBAAyB,EAAEA,yBAFd;AAIbM,QAAAA,eAAe,EAAE7D,KAAK,CAACoD,WAJV;AAKbU,QAAAA,aAAa,EAAE9D,KAAK,CAACyD,SALR;AAMbM,QAAAA,eAAe,EAAE/D,KAAK,CAACgD,WANV;AAObgB,QAAAA,YAAY,EAAEhE,KAAK,CAACwD,QAPP;AAQbS,QAAAA,eAAe,EAAEjE,KAAK,CAACqB,WAAN,KAAsB,IAR1B;AASb6C,QAAAA,kBAAkB,EAAElE,KAAK,CAACmE,cATb;AAUbC,QAAAA,eAAe,EAAEpE,KAAK,CAACqE,WAVV;AAYbC,QAAAA,aAAa,EAAE,CAZF;AAabC,QAAAA,qBAAqB,EAAE;AAbV,OADH;AAgBZlD,MAAAA,WAAW,EAAE,KAhBD;AAiBZmD,MAAAA,yBAAyB,EAAEnG,6BAA6B,CAACoG,wBAjB7C;AAkBZC,MAAAA,uBAAuB,EAAErG,6BAA6B,CAACoG,wBAlB3C;AAmBZE,MAAAA,UAAU,EAAE,CAnBA;AAoBZC,MAAAA,SAAS,EAAE,CApBC;AAqBZC,MAAAA,0BAA0B,EAAE,IArBhB;AAuBZvD,MAAAA,qBAAqB,EAAE;AAvBX,KAAd;;AA0BA,QAAItB,KAAK,CAACqE,WAAN,GAAoB,CAAxB,EAA2B;AACzBpE,MAAAA,KAAK,CAAC6E,iBAAN,GAA0B7E,KAAK,CAAC8E,uBAAN,CAA8B/E,KAA9B,EAAqCC,KAAK,CAAC0D,KAA3C,CAA1B;AACD;;AACD,QAAI3D,KAAK,CAACmE,cAAN,GAAuB,CAA3B,EAA8B;AAC5BlE,MAAAA,KAAK,CAAC+E,kBAAN,GAA2B/E,KAAK,CAACgF,wBAAN,CAA+BjF,KAA/B,EAAsCC,KAAK,CAAC0D,KAA5C,CAA3B;AACD;;AACD,WAAO1D,KAAP;AACD;AAED;;;;;AAKA,GAAC,GAAG5C,aAAa,CAACoC,OAAlB,EAA2BK,IAA3B,EAAiC,CAAC;AAChCT,IAAAA,GAAG,EAAE,kBAD2B;AAEhC9C,IAAAA,KAAK,EAAE,SAAS2I,gBAAT,GAA4B;AACjC,UAAIC,IAAI,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiB3I,SAAzC,GAAqD2I,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAA/E;AAAA,UACIE,cAAc,GAAGH,IAAI,CAACI,SAD1B;AAAA,UAEIA,SAAS,GAAGD,cAAc,KAAK7I,SAAnB,GAA+B,KAAKuD,KAAL,CAAWwF,iBAA1C,GAA8DF,cAF9E;AAAA,UAGIG,gBAAgB,GAAGN,IAAI,CAACO,WAH5B;AAAA,UAIIA,WAAW,GAAGD,gBAAgB,KAAKhJ,SAArB,GAAiC,KAAKuD,KAAL,CAAWmE,cAA5C,GAA6DsB,gBAJ/E;AAAA,UAKIE,aAAa,GAAGR,IAAI,CAACS,QALzB;AAAA,UAMIA,QAAQ,GAAGD,aAAa,KAAKlJ,SAAlB,GAA8B,KAAKuD,KAAL,CAAWqE,WAAzC,GAAuDsB,aANtE;;AAQA,UAAIE,WAAW,GAAG,CAAC,GAAG9I,SAAS,CAAC0C,OAAd,EAAuB,EAAvB,EAA2B,KAAKO,KAAhC,EAAuC;AACvDwF,QAAAA,iBAAiB,EAAED,SADoC;AAEvDpB,QAAAA,cAAc,EAAEuB,WAFuC;AAGvDrB,QAAAA,WAAW,EAAEuB;AAH0C,OAAvC,CAAlB;AAMA,aAAO;AACLjB,QAAAA,UAAU,EAAE,KAAKM,wBAAL,CAA8BY,WAA9B,CADP;AAELjB,QAAAA,SAAS,EAAE,KAAKG,uBAAL,CAA6Bc,WAA7B;AAFN,OAAP;AAID;AAED;;;;AAvBgC,GAAD,EA2B9B;AACDxG,IAAAA,GAAG,EAAE,oBADJ;AAED9C,IAAAA,KAAK,EAAE,SAASuJ,kBAAT,GAA8B;AACnC,aAAO,KAAKnC,KAAL,CAAWC,aAAX,CAAyBL,yBAAzB,CAAmDwC,YAAnD,EAAP;AACD;AAED;;;;AANC,GA3B8B,EAqC9B;AACD1G,IAAAA,GAAG,EAAE,sBADJ;AAED9C,IAAAA,KAAK,EAAE,SAASyJ,oBAAT,GAAgC;AACrC,aAAO,KAAKrC,KAAL,CAAWC,aAAX,CAAyBd,4BAAzB,CAAsDiD,YAAtD,EAAP;AACD;AAED;;;;;AANC,GArC8B,EAgD9B;AACD1G,IAAAA,GAAG,EAAE,mBADJ;AAED9C,IAAAA,KAAK,EAAE,SAASsG,iBAAT,CAA2BoD,KAA3B,EAAkC;AACvC,UAAIC,gBAAgB,GAAGD,KAAK,CAACtB,UAA7B;AAAA,UACIwB,eAAe,GAAGD,gBAAgB,KAAKzJ,SAArB,GAAiC,CAAjC,GAAqCyJ,gBAD3D;AAAA,UAEIE,eAAe,GAAGH,KAAK,CAACrB,SAF5B;AAAA,UAGIyB,cAAc,GAAGD,eAAe,KAAK3J,SAApB,GAAgC,CAAhC,GAAoC2J,eAHzD,CADuC,CAMvC;AACA;;AACA,UAAIC,cAAc,GAAG,CAArB,EAAwB;AACtB;AACD,OAVsC,CAYvC;;;AACA,WAAKC,oBAAL;;AAEA,UAAIC,MAAM,GAAG,KAAKvG,KAAlB;AAAA,UACIwG,UAAU,GAAGD,MAAM,CAACC,UADxB;AAAA,UAEIC,SAAS,GAAGF,MAAM,CAACE,SAFvB;AAAA,UAGIC,MAAM,GAAGH,MAAM,CAACG,MAHpB;AAAA,UAIIC,KAAK,GAAGJ,MAAM,CAACI,KAJnB;AAKA,UAAI/C,aAAa,GAAG,KAAKD,KAAL,CAAWC,aAA/B,CApBuC,CAsBvC;AACA;AACA;AACA;;AAEA,UAAIU,aAAa,GAAGV,aAAa,CAACU,aAAlC;AACA,UAAIsC,eAAe,GAAGhD,aAAa,CAACL,yBAAd,CAAwCwC,YAAxC,EAAtB;AACA,UAAIc,iBAAiB,GAAGjD,aAAa,CAACd,4BAAd,CAA2CiD,YAA3C,EAAxB;AACA,UAAIpB,UAAU,GAAGmC,IAAI,CAACC,GAAL,CAASD,IAAI,CAACE,GAAL,CAAS,CAAT,EAAYH,iBAAiB,GAAGF,KAApB,GAA4BrC,aAAxC,CAAT,EAAiE6B,eAAjE,CAAjB;AACA,UAAIvB,SAAS,GAAGkC,IAAI,CAACC,GAAL,CAASD,IAAI,CAACE,GAAL,CAAS,CAAT,EAAYJ,eAAe,GAAGF,MAAlB,GAA2BpC,aAAvC,CAAT,EAAgE+B,cAAhE,CAAhB,CA/BuC,CAiCvC;AACA;AACA;AACA;;AACA,UAAI,KAAK1C,KAAL,CAAWgB,UAAX,KAA0BA,UAA1B,IAAwC,KAAKhB,KAAL,CAAWiB,SAAX,KAAyBA,SAArE,EAAgF;AAC9E;AACA;AACA,YAAIqC,0BAA0B,GAAGtC,UAAU,KAAK,KAAKhB,KAAL,CAAWgB,UAA1B,GAAuCA,UAAU,GAAG,KAAKhB,KAAL,CAAWgB,UAAxB,GAAqCtG,6BAA6B,CAACoG,wBAAnE,GAA8FpG,6BAA6B,CAAC6I,yBAAnK,GAA+L,KAAKvD,KAAL,CAAWa,yBAA3O;;AACA,YAAI2C,wBAAwB,GAAGvC,SAAS,KAAK,KAAKjB,KAAL,CAAWiB,SAAzB,GAAqCA,SAAS,GAAG,KAAKjB,KAAL,CAAWiB,SAAvB,GAAmCvG,6BAA6B,CAACoG,wBAAjE,GAA4FpG,6BAA6B,CAAC6I,yBAA/J,GAA2L,KAAKvD,KAAL,CAAWe,uBAArO;;AAEA,YAAI0C,QAAQ,GAAG;AACb/F,UAAAA,WAAW,EAAE,IADA;AAEbmD,UAAAA,yBAAyB,EAAEyC,0BAFd;AAGbvC,UAAAA,uBAAuB,EAAEyC,wBAHZ;AAIbtC,UAAAA,0BAA0B,EAAEnF,8BAA8B,CAACC;AAJ9C,SAAf;;AAOA,YAAI,CAAC6G,UAAL,EAAiB;AACfY,UAAAA,QAAQ,CAACxC,SAAT,GAAqBA,SAArB;AACD;;AAED,YAAI,CAAC6B,SAAL,EAAgB;AACdW,UAAAA,QAAQ,CAACzC,UAAT,GAAsBA,UAAtB;AACD;;AAEDyC,QAAAA,QAAQ,CAAC9F,qBAAT,GAAiC,KAAjC;AACA,aAAKF,QAAL,CAAcgG,QAAd;AACD;;AAED,WAAKC,uBAAL,CAA6B;AAC3B1C,QAAAA,UAAU,EAAEA,UADe;AAE3BC,QAAAA,SAAS,EAAEA,SAFgB;AAG3BiC,QAAAA,iBAAiB,EAAEA,iBAHQ;AAI3BD,QAAAA,eAAe,EAAEA;AAJU,OAA7B;AAMD;AAED;;;;;;AAMA;;AA9EC,GAhD8B,EAgI9B;AACDvH,IAAAA,GAAG,EAAE,+BADJ;AAED9C,IAAAA,KAAK,EAAE,SAAS+K,6BAAT,CAAuCC,KAAvC,EAA8C;AACnD,UAAI7B,WAAW,GAAG6B,KAAK,CAAC7B,WAAxB;AAAA,UACIE,QAAQ,GAAG2B,KAAK,CAAC3B,QADrB;AAGA,WAAKvF,8BAAL,GAAsC,OAAO,KAAKA,8BAAZ,KAA+C,QAA/C,GAA0DyG,IAAI,CAACC,GAAL,CAAS,KAAK1G,8BAAd,EAA8CqF,WAA9C,CAA1D,GAAuHA,WAA7J;AACA,WAAKpF,2BAAL,GAAmC,OAAO,KAAKA,2BAAZ,KAA4C,QAA5C,GAAuDwG,IAAI,CAACC,GAAL,CAAS,KAAKzG,2BAAd,EAA2CsF,QAA3C,CAAvD,GAA8GA,QAAjJ;AACD;AAED;;;;;;AAVC,GAhI8B,EAgJ9B;AACDvG,IAAAA,GAAG,EAAE,iBADJ;AAED9C,IAAAA,KAAK,EAAE,SAASiL,eAAT,GAA2B;AAChC,UAAIC,OAAO,GAAG,KAAKzH,KAAnB;AAAA,UACIgD,WAAW,GAAGyE,OAAO,CAACzE,WAD1B;AAAA,UAEIQ,QAAQ,GAAGiE,OAAO,CAACjE,QAFvB;AAGA,UAAII,aAAa,GAAG,KAAKD,KAAL,CAAWC,aAA/B;AAEAA,MAAAA,aAAa,CAACd,4BAAd,CAA2C4E,wBAA3C,CAAoE1E,WAAW,GAAG,CAAlF;AACAY,MAAAA,aAAa,CAACL,yBAAd,CAAwCmE,wBAAxC,CAAiElE,QAAQ,GAAG,CAA5E;AACD;AAED;;;;;;AAZC,GAhJ8B,EAkK9B;AACDnE,IAAAA,GAAG,EAAE,mBADJ;AAED9C,IAAAA,KAAK,EAAE,SAASoL,iBAAT,GAA6B;AAClC,UAAIC,KAAK,GAAGxC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiB3I,SAAzC,GAAqD2I,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAhF;AAAA,UACIyC,iBAAiB,GAAGD,KAAK,CAAClC,WAD9B;AAAA,UAEIA,WAAW,GAAGmC,iBAAiB,KAAKpL,SAAtB,GAAkC,CAAlC,GAAsCoL,iBAFxD;AAAA,UAGIC,cAAc,GAAGF,KAAK,CAAChC,QAH3B;AAAA,UAIIA,QAAQ,GAAGkC,cAAc,KAAKrL,SAAnB,GAA+B,CAA/B,GAAmCqL,cAJlD;;AAMA,UAAIC,OAAO,GAAG,KAAK/H,KAAnB;AAAA,UACImE,cAAc,GAAG4D,OAAO,CAAC5D,cAD7B;AAAA,UAEIE,WAAW,GAAG0D,OAAO,CAAC1D,WAF1B;AAGA,UAAIT,aAAa,GAAG,KAAKD,KAAL,CAAWC,aAA/B;AAGAA,MAAAA,aAAa,CAACd,4BAAd,CAA2CkF,SAA3C,CAAqDtC,WAArD;AACA9B,MAAAA,aAAa,CAACL,yBAAd,CAAwCyE,SAAxC,CAAkDpC,QAAlD,EAdkC,CAgBlC;AACA;AACA;;AACA,WAAKrF,wBAAL,GAAgC4D,cAAc,IAAI,CAAlB,KAAwB,KAAKR,KAAL,CAAWa,yBAAX,KAAyCnG,6BAA6B,CAACoG,wBAAvE,GAAkGiB,WAAW,IAAIvB,cAAjH,GAAkIuB,WAAW,IAAIvB,cAAzK,CAAhC;AACA,WAAK3D,uBAAL,GAA+B6D,WAAW,IAAI,CAAf,KAAqB,KAAKV,KAAL,CAAWe,uBAAX,KAAuCrG,6BAA6B,CAACoG,wBAArE,GAAgGmB,QAAQ,IAAIvB,WAA5G,GAA0HuB,QAAQ,IAAIvB,WAA3J,CAA/B,CApBkC,CAsBlC;AACA;;AACA,WAAKrD,WAAL,GAAmB,EAAnB;AACA,WAAKC,UAAL,GAAkB,EAAlB;AAEA,WAAKgH,WAAL;AACD;AAED;;;;AAhCC,GAlK8B,EAsM9B;AACD5I,IAAAA,GAAG,EAAE,cADJ;AAED9C,IAAAA,KAAK,EAAE,SAAS2L,YAAT,CAAsBC,KAAtB,EAA6B;AAClC,UAAIzC,WAAW,GAAGyC,KAAK,CAACzC,WAAxB;AAAA,UACIE,QAAQ,GAAGuC,KAAK,CAACvC,QADrB;AAEA,UAAI5C,WAAW,GAAG,KAAKhD,KAAL,CAAWgD,WAA7B;AAGA,UAAIhD,KAAK,GAAG,KAAKA,KAAjB,CANkC,CAQlC;AACA;;AACA,UAAIgD,WAAW,GAAG,CAAd,IAAmB0C,WAAW,KAAKjJ,SAAvC,EAAkD;AAChD,aAAK2L,kCAAL,CAAwC,CAAC,GAAGrL,SAAS,CAAC0C,OAAd,EAAuB,EAAvB,EAA2BO,KAA3B,EAAkC;AACxEmE,UAAAA,cAAc,EAAEuB;AADwD,SAAlC,CAAxC;AAGD;;AAED,UAAIE,QAAQ,KAAKnJ,SAAjB,EAA4B;AAC1B,aAAK4L,8BAAL,CAAoC,CAAC,GAAGtL,SAAS,CAAC0C,OAAd,EAAuB,EAAvB,EAA2BO,KAA3B,EAAkC;AACpEqE,UAAAA,WAAW,EAAEuB;AADuD,SAAlC,CAApC;AAGD;AACF;AAvBA,GAtM8B,EA8N9B;AACDvG,IAAAA,GAAG,EAAE,mBADJ;AAED9C,IAAAA,KAAK,EAAE,SAAS+L,iBAAT,GAA6B;AAClC,UAAIC,OAAO,GAAG,KAAKvI,KAAnB;AAAA,UACIwI,gBAAgB,GAAGD,OAAO,CAACC,gBAD/B;AAAA,UAEI9B,MAAM,GAAG6B,OAAO,CAAC7B,MAFrB;AAAA,UAGI/B,UAAU,GAAG4D,OAAO,CAAC5D,UAHzB;AAAA,UAIIR,cAAc,GAAGoE,OAAO,CAACpE,cAJ7B;AAAA,UAKIS,SAAS,GAAG2D,OAAO,CAAC3D,SALxB;AAAA,UAMIP,WAAW,GAAGkE,OAAO,CAAClE,WAN1B;AAAA,UAOIsC,KAAK,GAAG4B,OAAO,CAAC5B,KAPpB;AAQA,UAAI/C,aAAa,GAAG,KAAKD,KAAL,CAAWC,aAA/B,CATkC,CAWlC;;AAEA,WAAKkB,iBAAL,GAAyB,CAAzB;AACA,WAAKE,kBAAL,GAA0B,CAA1B,CAdkC,CAgBlC;AACA;;AACA,WAAKyD,0BAAL,GAlBkC,CAoBlC;AACA;;;AACA,UAAI,CAAC7E,aAAa,CAACW,qBAAnB,EAA0C;AACxC,aAAKnD,QAAL,CAAc,UAAUsH,SAAV,EAAqB;AACjC,cAAIC,WAAW,GAAG,CAAC,GAAG5L,SAAS,CAAC0C,OAAd,EAAuB,EAAvB,EAA2BiJ,SAA3B,EAAsC;AAAEpH,YAAAA,qBAAqB,EAAE;AAAzB,WAAtC,CAAlB;AACAqH,UAAAA,WAAW,CAAC/E,aAAZ,CAA0BU,aAA1B,GAA0CkE,gBAAgB,EAA1D;AACAG,UAAAA,WAAW,CAAC/E,aAAZ,CAA0BW,qBAA1B,GAAkD,IAAlD;AACA,iBAAOoE,WAAP;AACD,SALD;AAMD;;AAED,UAAI,OAAOhE,UAAP,KAAsB,QAAtB,IAAkCA,UAAU,IAAI,CAAhD,IAAqD,OAAOC,SAAP,KAAqB,QAArB,IAAiCA,SAAS,IAAI,CAAvG,EAA0G;AACxG,YAAI+D,WAAW,GAAG7I,IAAI,CAAC8I,+BAAL,CAAqC;AACrDF,UAAAA,SAAS,EAAE,KAAK/E,KADqC;AAErDgB,UAAAA,UAAU,EAAEA,UAFyC;AAGrDC,UAAAA,SAAS,EAAEA;AAH0C,SAArC,CAAlB;;AAKA,YAAI+D,WAAJ,EAAiB;AACfA,UAAAA,WAAW,CAACrH,qBAAZ,GAAoC,KAApC;AACA,eAAKF,QAAL,CAAcuH,WAAd;AACD;AACF,OAzCiC,CA2ClC;;;AACA,UAAI,KAAKlG,mBAAT,EAA8B;AAC5B;AACA;AACA,YAAI,KAAKA,mBAAL,CAAyBkC,UAAzB,KAAwC,KAAKhB,KAAL,CAAWgB,UAAvD,EAAmE;AACjE,eAAKlC,mBAAL,CAAyBkC,UAAzB,GAAsC,KAAKhB,KAAL,CAAWgB,UAAjD;AACD;;AACD,YAAI,KAAKlC,mBAAL,CAAyBmC,SAAzB,KAAuC,KAAKjB,KAAL,CAAWiB,SAAtD,EAAiE;AAC/D,eAAKnC,mBAAL,CAAyBmC,SAAzB,GAAqC,KAAKjB,KAAL,CAAWiB,SAAhD;AACD;AACF,OArDiC,CAuDlC;AACA;;;AACA,UAAIiE,oBAAoB,GAAGnC,MAAM,GAAG,CAAT,IAAcC,KAAK,GAAG,CAAjD;;AACA,UAAIxC,cAAc,IAAI,CAAlB,IAAuB0E,oBAA3B,EAAiD;AAC/C,aAAKT,kCAAL;AACD;;AACD,UAAI/D,WAAW,IAAI,CAAf,IAAoBwE,oBAAxB,EAA8C;AAC5C,aAAKR,8BAAL;AACD,OA/DiC,CAiElC;;;AACA,WAAK9G,2BAAL,GAlEkC,CAoElC;;;AACA,WAAK8F,uBAAL,CAA6B;AAC3B1C,QAAAA,UAAU,EAAEA,UAAU,IAAI,CADC;AAE3BC,QAAAA,SAAS,EAAEA,SAAS,IAAI,CAFG;AAG3BiC,QAAAA,iBAAiB,EAAEjD,aAAa,CAACd,4BAAd,CAA2CiD,YAA3C,EAHQ;AAI3Ba,QAAAA,eAAe,EAAEhD,aAAa,CAACL,yBAAd,CAAwCwC,YAAxC;AAJU,OAA7B;;AAOA,WAAK+C,mCAAL;AACD;AAED;;;;;;AAjFC,GA9N8B,EAqT9B;AACDzJ,IAAAA,GAAG,EAAE,oBADJ;AAED9C,IAAAA,KAAK,EAAE,SAASwM,kBAAT,CAA4BC,SAA5B,EAAuCN,SAAvC,EAAkD;AACvD,UAAIO,MAAM,GAAG,IAAb;;AAEA,UAAIC,OAAO,GAAG,KAAKlJ,KAAnB;AAAA,UACIwG,UAAU,GAAG0C,OAAO,CAAC1C,UADzB;AAAA,UAEIC,SAAS,GAAGyC,OAAO,CAACzC,SAFxB;AAAA,UAGIzD,WAAW,GAAGkG,OAAO,CAAClG,WAH1B;AAAA,UAII0D,MAAM,GAAGwC,OAAO,CAACxC,MAJrB;AAAA,UAKIlD,QAAQ,GAAG0F,OAAO,CAAC1F,QALvB;AAAA,UAMIgC,iBAAiB,GAAG0D,OAAO,CAAC1D,iBANhC;AAAA,UAOIrB,cAAc,GAAG+E,OAAO,CAAC/E,cAP7B;AAAA,UAQIE,WAAW,GAAG6E,OAAO,CAAC7E,WAR1B;AAAA,UASIsC,KAAK,GAAGuC,OAAO,CAACvC,KATpB;AAUA,UAAIwC,MAAM,GAAG,KAAKxF,KAAlB;AAAA,UACIgB,UAAU,GAAGwE,MAAM,CAACxE,UADxB;AAAA,UAEIE,0BAA0B,GAAGsE,MAAM,CAACtE,0BAFxC;AAAA,UAGID,SAAS,GAAGuE,MAAM,CAACvE,SAHvB;AAAA,UAIIhB,aAAa,GAAGuF,MAAM,CAACvF,aAJ3B,CAbuD,CAkBvD;AACA;;AAEA,WAAK6E,0BAAL,GArBuD,CAuBvD;AACA;AACA;;;AACA,UAAIW,qCAAqC,GAAGpG,WAAW,GAAG,CAAd,IAAmBgG,SAAS,CAAChG,WAAV,KAA0B,CAA7C,IAAkDQ,QAAQ,GAAG,CAAX,IAAgBwF,SAAS,CAACxF,QAAV,KAAuB,CAArI,CA1BuD,CA4BvD;AACA;AACA;AACA;AACA;;AACA,UAAIqB,0BAA0B,KAAKnF,8BAA8B,CAACE,SAAlE,EAA6E;AAC3E;AACA;AACA,YAAI,CAAC6G,SAAD,IAAc9B,UAAU,IAAI,CAA5B,KAAkCA,UAAU,KAAK,KAAKlC,mBAAL,CAAyBkC,UAAxC,IAAsDyE,qCAAxF,CAAJ,EAAoI;AAClI,eAAK3G,mBAAL,CAAyBkC,UAAzB,GAAsCA,UAAtC;AACD;;AACD,YAAI,CAAC6B,UAAD,IAAe5B,SAAS,IAAI,CAA5B,KAAkCA,SAAS,KAAK,KAAKnC,mBAAL,CAAyBmC,SAAvC,IAAoDwE,qCAAtF,CAAJ,EAAkI;AAChI,eAAK3G,mBAAL,CAAyBmC,SAAzB,GAAqCA,SAArC;AACD;AACF,OA1CsD,CA4CvD;AACA;AACA;;;AACA,UAAIyE,yBAAyB,GAAG,CAACL,SAAS,CAACrC,KAAV,KAAoB,CAApB,IAAyBqC,SAAS,CAACtC,MAAV,KAAqB,CAA/C,KAAqDA,MAAM,GAAG,CAA9D,IAAmEC,KAAK,GAAG,CAA3G,CA/CuD,CAiDvD;AACA;;AACA,UAAI,KAAKpG,wBAAT,EAAmC;AACjC,aAAKA,wBAAL,GAAgC,KAAhC;;AACA,aAAK6H,kCAAL,CAAwC,KAAKpI,KAA7C;AACD,OAHD,MAGO;AACL,SAAC,GAAGxB,yBAAyB,CAACiB,OAA9B,EAAuC;AACrC6J,UAAAA,0BAA0B,EAAE1F,aAAa,CAACd,4BADL;AAErCyG,UAAAA,kBAAkB,EAAEP,SAAS,CAAChG,WAFO;AAGrCwG,UAAAA,gBAAgB,EAAER,SAAS,CAAC5F,WAHS;AAIrCqG,UAAAA,yBAAyB,EAAET,SAAS,CAACxD,iBAJA;AAKrCkE,UAAAA,qBAAqB,EAAEV,SAAS,CAAC7E,cALI;AAMrCwF,UAAAA,YAAY,EAAEX,SAAS,CAACrC,KANa;AAOrCiD,UAAAA,YAAY,EAAEjF,UAPuB;AAQrCa,UAAAA,iBAAiB,EAAEA,iBARkB;AASrCqE,UAAAA,aAAa,EAAE1F,cATsB;AAUrC2F,UAAAA,IAAI,EAAEnD,KAV+B;AAWrC0C,UAAAA,yBAAyB,EAAEA,yBAXU;AAYrCU,UAAAA,yBAAyB,EAAE,SAASA,yBAAT,GAAqC;AAC9D,mBAAOd,MAAM,CAACb,kCAAP,CAA0Ca,MAAM,CAACjJ,KAAjD,CAAP;AACD;AAdoC,SAAvC;AAgBD;;AAED,UAAI,KAAKQ,uBAAT,EAAkC;AAChC,aAAKA,uBAAL,GAA+B,KAA/B;;AACA,aAAK6H,8BAAL,CAAoC,KAAKrI,KAAzC;AACD,OAHD,MAGO;AACL,SAAC,GAAGxB,yBAAyB,CAACiB,OAA9B,EAAuC;AACrC6J,UAAAA,0BAA0B,EAAE1F,aAAa,CAACL,yBADL;AAErCgG,UAAAA,kBAAkB,EAAEP,SAAS,CAACxF,QAFO;AAGrCgG,UAAAA,gBAAgB,EAAER,SAAS,CAACvF,SAHS;AAIrCgG,UAAAA,yBAAyB,EAAET,SAAS,CAACxD,iBAJA;AAKrCkE,UAAAA,qBAAqB,EAAEV,SAAS,CAAC3E,WALI;AAMrCsF,UAAAA,YAAY,EAAEX,SAAS,CAACtC,MANa;AAOrCkD,UAAAA,YAAY,EAAEhF,SAPuB;AAQrCY,UAAAA,iBAAiB,EAAEA,iBARkB;AASrCqE,UAAAA,aAAa,EAAExF,WATsB;AAUrCyF,UAAAA,IAAI,EAAEpD,MAV+B;AAWrC2C,UAAAA,yBAAyB,EAAEA,yBAXU;AAYrCU,UAAAA,yBAAyB,EAAE,SAASA,yBAAT,GAAqC;AAC9D,mBAAOd,MAAM,CAACZ,8BAAP,CAAsCY,MAAM,CAACjJ,KAA7C,CAAP;AACD;AAdoC,SAAvC;AAgBD,OA7FsD,CA+FvD;;;AACA,WAAKuB,2BAAL,GAhGuD,CAkGvD;;;AACA,UAAIoD,UAAU,KAAK+D,SAAS,CAAC/D,UAAzB,IAAuCC,SAAS,KAAK8D,SAAS,CAAC9D,SAAnE,EAA8E;AAC5E,YAAIgC,eAAe,GAAGhD,aAAa,CAACL,yBAAd,CAAwCwC,YAAxC,EAAtB;AACA,YAAIc,iBAAiB,GAAGjD,aAAa,CAACd,4BAAd,CAA2CiD,YAA3C,EAAxB;;AAEA,aAAKsB,uBAAL,CAA6B;AAC3B1C,UAAAA,UAAU,EAAEA,UADe;AAE3BC,UAAAA,SAAS,EAAEA,SAFgB;AAG3BiC,UAAAA,iBAAiB,EAAEA,iBAHQ;AAI3BD,UAAAA,eAAe,EAAEA;AAJU,SAA7B;AAMD;;AAED,WAAKkC,mCAAL;AACD;AAlHA,GArT8B,EAwa9B;AACDzJ,IAAAA,GAAG,EAAE,sBADJ;AAED9C,IAAAA,KAAK,EAAE,SAASyN,oBAAT,GAAgC;AACrC,UAAI,KAAK7I,8BAAT,EAAyC;AACvC,SAAC,GAAGrC,wBAAwB,CAACmL,sBAA7B,EAAqD,KAAK9I,8BAA1D;AACD;AACF;AAED;;;;;;;AARC,GAxa8B,EAub9B;AACD9B,IAAAA,GAAG,EAAE,QADJ;AAED9C,IAAAA,KAAK,EAAE,SAAS2N,MAAT,GAAkB;AACvB,UAAIC,OAAO,GAAG,KAAKnK,KAAnB;AAAA,UACIoK,kBAAkB,GAAGD,OAAO,CAACC,kBADjC;AAAA,UAEI5D,UAAU,GAAG2D,OAAO,CAAC3D,UAFzB;AAAA,UAGIC,SAAS,GAAG0D,OAAO,CAAC1D,SAHxB;AAAA,UAII4D,SAAS,GAAGF,OAAO,CAACE,SAJxB;AAAA,UAKIC,cAAc,GAAGH,OAAO,CAACG,cAL7B;AAAA,UAMIC,aAAa,GAAGJ,OAAO,CAACI,aAN5B;AAAA,UAOIC,cAAc,GAAGL,OAAO,CAACK,cAP7B;AAAA,UAQI9D,MAAM,GAAGyD,OAAO,CAACzD,MARrB;AAAA,UASI+D,EAAE,GAAGN,OAAO,CAACM,EATjB;AAAA,UAUIC,iBAAiB,GAAGP,OAAO,CAACO,iBAVhC;AAAA,UAWIC,IAAI,GAAGR,OAAO,CAACQ,IAXnB;AAAA,UAYIC,KAAK,GAAGT,OAAO,CAACS,KAZpB;AAAA,UAaIC,QAAQ,GAAGV,OAAO,CAACU,QAbvB;AAAA,UAcIlE,KAAK,GAAGwD,OAAO,CAACxD,KAdpB;AAeA,UAAImE,OAAO,GAAG,KAAKnH,KAAnB;AAAA,UACIC,aAAa,GAAGkH,OAAO,CAAClH,aAD5B;AAAA,UAEItC,qBAAqB,GAAGwJ,OAAO,CAACxJ,qBAFpC;;AAKA,UAAID,WAAW,GAAG,KAAK0J,YAAL,EAAlB;;AAEA,UAAIC,SAAS,GAAG;AACdC,QAAAA,SAAS,EAAE,YADG;AAEdC,QAAAA,SAAS,EAAE,KAFG;AAGdxE,QAAAA,MAAM,EAAEF,UAAU,GAAG,MAAH,GAAYE,MAHhB;AAIdyE,QAAAA,QAAQ,EAAE,UAJI;AAKdxE,QAAAA,KAAK,EAAEF,SAAS,GAAG,MAAH,GAAYE,KALd;AAMdyE,QAAAA,uBAAuB,EAAE,OANX;AAOdC,QAAAA,UAAU,EAAE;AAPE,OAAhB;;AAUA,UAAI/J,qBAAJ,EAA2B;AACzB,aAAKN,WAAL,GAAmB,EAAnB;AACD,OAnCsB,CAqCvB;AACA;;;AACA,UAAI,CAAC,KAAK2C,KAAL,CAAWtC,WAAhB,EAA6B;AAC3B,aAAKiK,gBAAL;AACD,OAzCsB,CA2CvB;;;AACA,WAAKC,0BAAL,CAAgC,KAAKvL,KAArC,EAA4C,KAAK2D,KAAjD;;AAEA,UAAIkD,iBAAiB,GAAGjD,aAAa,CAACd,4BAAd,CAA2CiD,YAA3C,EAAxB;AACA,UAAIa,eAAe,GAAGhD,aAAa,CAACL,yBAAd,CAAwCwC,YAAxC,EAAtB,CA/CuB,CAiDvB;AACA;AACA;;AACA,UAAIyF,qBAAqB,GAAG5E,eAAe,GAAGF,MAAlB,GAA2B9C,aAAa,CAACU,aAAzC,GAAyD,CAArF;AACA,UAAImH,uBAAuB,GAAG5E,iBAAiB,GAAGF,KAApB,GAA4B/C,aAAa,CAACU,aAA1C,GAA0D,CAAxF;;AAEA,UAAImH,uBAAuB,KAAK,KAAKhL,wBAAjC,IAA6D+K,qBAAqB,KAAK,KAAK9K,sBAAhG,EAAwH;AACtH,aAAKD,wBAAL,GAAgCgL,uBAAhC;AACA,aAAK/K,sBAAL,GAA8B8K,qBAA9B;AACA,aAAK7K,yBAAL,GAAiC,IAAjC;AACD,OA3DsB,CA6DvB;AACA;AACA;AACA;AACA;;;AACAqK,MAAAA,SAAS,CAACU,SAAV,GAAsB7E,iBAAiB,GAAG2E,qBAApB,IAA6C7E,KAA7C,GAAqD,QAArD,GAAgE,MAAtF;AACAqE,MAAAA,SAAS,CAACW,SAAV,GAAsB/E,eAAe,GAAG6E,uBAAlB,IAA6C/E,MAA7C,GAAsD,QAAtD,GAAiE,MAAvF;AAEA,UAAIkF,iBAAiB,GAAG,KAAKC,kBAA7B;AAEA,UAAIC,qBAAqB,GAAGF,iBAAiB,CAACvG,MAAlB,KAA6B,CAA7B,IAAkCqB,MAAM,GAAG,CAA3C,IAAgDC,KAAK,GAAG,CAApF;AAEA,aAAOhJ,KAAK,CAACoO,aAAN,CACL,KADK,EAEL,CAAC,GAAGhP,SAAS,CAAC0C,OAAd,EAAuB;AACrB+C,QAAAA,GAAG,EAAE,KAAKD;AADW,OAAvB,EAEG+H,cAFH,EAEmB;AACjB,sBAAc,KAAKtK,KAAL,CAAW,YAAX,CADG;AAEjB,yBAAiB,KAAKA,KAAL,CAAW,eAAX,CAFA;AAGjBqK,QAAAA,SAAS,EAAE,CAAC,GAAGvM,MAAM,CAAC2B,OAAX,EAAoB,wBAApB,EAA8C4K,SAA9C,CAHM;AAIjBI,QAAAA,EAAE,EAAEA,EAJa;AAKjBuB,QAAAA,QAAQ,EAAE,KAAKtJ,SALE;AAMjBiI,QAAAA,IAAI,EAAEA,IANW;AAOjBC,QAAAA,KAAK,EAAE,CAAC,GAAG7N,SAAS,CAAC0C,OAAd,EAAuB,EAAvB,EAA2BuL,SAA3B,EAAsCJ,KAAtC,CAPU;AAQjBC,QAAAA,QAAQ,EAAEA;AARO,OAFnB,CAFK,EAaLe,iBAAiB,CAACvG,MAAlB,GAA2B,CAA3B,IAAgC1H,KAAK,CAACoO,aAAN,CAC9B,KAD8B,EAE9B;AACE1B,QAAAA,SAAS,EAAE,8CADb;AAEEM,QAAAA,IAAI,EAAEJ,aAFR;AAGEK,QAAAA,KAAK,EAAE,CAAC,GAAG7N,SAAS,CAAC0C,OAAd,EAAuB;AAC5BkH,UAAAA,KAAK,EAAEyD,kBAAkB,GAAG,MAAH,GAAYvD,iBADT;AAE5BH,UAAAA,MAAM,EAAEE,eAFoB;AAG5BqF,UAAAA,QAAQ,EAAEpF,iBAHkB;AAI5BqF,UAAAA,SAAS,EAAEtF,eAJiB;AAK5BuF,UAAAA,QAAQ,EAAE,QALkB;AAM5BC,UAAAA,aAAa,EAAE/K,WAAW,GAAG,MAAH,GAAY,EANV;AAO5B8J,UAAAA,QAAQ,EAAE;AAPkB,SAAvB,EAQJX,cARI;AAHT,OAF8B,EAc9BoB,iBAd8B,CAb3B,EA6BLE,qBAAqB,IAAIpB,iBAAiB,EA7BrC,CAAP;AA+BD;AAED;;AA5GC,GAvb8B,EAqiB9B;AACDrL,IAAAA,GAAG,EAAE,4BADJ;AAED9C,IAAAA,KAAK,EAAE,SAASgP,0BAAT,GAAsC;AAC3C,UAAIvL,KAAK,GAAGoF,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiB3I,SAAzC,GAAqD2I,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAKpF,KAArF;AACA,UAAI2D,KAAK,GAAGyB,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiB3I,SAAzC,GAAqD2I,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAKzB,KAArF;AACA,UAAI0I,YAAY,GAAGrM,KAAK,CAACqM,YAAzB;AAAA,UACIC,iBAAiB,GAAGtM,KAAK,CAACsM,iBAD9B;AAAA,UAEItJ,WAAW,GAAGhD,KAAK,CAACgD,WAFxB;AAAA,UAGIuJ,wBAAwB,GAAGvM,KAAK,CAACuM,wBAHrC;AAAA,UAII7F,MAAM,GAAG1G,KAAK,CAAC0G,MAJnB;AAAA,UAKI8F,mBAAmB,GAAGxM,KAAK,CAACwM,mBALhC;AAAA,UAMIC,qBAAqB,GAAGzM,KAAK,CAACyM,qBANlC;AAAA,UAOIC,gBAAgB,GAAG1M,KAAK,CAAC0M,gBAP7B;AAAA,UAQIlJ,QAAQ,GAAGxD,KAAK,CAACwD,QARrB;AAAA,UASImD,KAAK,GAAG3G,KAAK,CAAC2G,KATlB;AAAA,UAUIgG,iBAAiB,GAAG3M,KAAK,CAAC2M,iBAV9B;AAWA,UAAInI,yBAAyB,GAAGb,KAAK,CAACa,yBAAtC;AAAA,UACIE,uBAAuB,GAAGf,KAAK,CAACe,uBADpC;AAAA,UAEId,aAAa,GAAGD,KAAK,CAACC,aAF1B;AAKA,UAAIgB,SAAS,GAAG,KAAKE,iBAAL,GAAyB,CAAzB,GAA6B,KAAKA,iBAAlC,GAAsDnB,KAAK,CAACiB,SAA5E;AACA,UAAID,UAAU,GAAG,KAAKK,kBAAL,GAA0B,CAA1B,GAA8B,KAAKA,kBAAnC,GAAwDrB,KAAK,CAACgB,UAA/E;;AAEA,UAAItD,WAAW,GAAG,KAAK0J,YAAL,CAAkB/K,KAAlB,EAAyB2D,KAAzB,CAAlB;;AAEA,WAAKkI,kBAAL,GAA0B,EAA1B,CAxB2C,CA0B3C;;AACA,UAAInF,MAAM,GAAG,CAAT,IAAcC,KAAK,GAAG,CAA1B,EAA6B;AAC3B,YAAIiG,oBAAoB,GAAGhJ,aAAa,CAACd,4BAAd,CAA2C+J,mBAA3C,CAA+D;AACxFC,UAAAA,aAAa,EAAEnG,KADyE;AAExFoG,UAAAA,MAAM,EAAEpI;AAFgF,SAA/D,CAA3B;AAIA,YAAIqI,iBAAiB,GAAGpJ,aAAa,CAACL,yBAAd,CAAwCsJ,mBAAxC,CAA4D;AAClFC,UAAAA,aAAa,EAAEpG,MADmE;AAElFqG,UAAAA,MAAM,EAAEnI;AAF0E,SAA5D,CAAxB;AAKA,YAAIqI,0BAA0B,GAAGrJ,aAAa,CAACd,4BAAd,CAA2CoK,mBAA3C,CAA+D;AAC9FJ,UAAAA,aAAa,EAAEnG,KAD+E;AAE9FoG,UAAAA,MAAM,EAAEpI;AAFsF,SAA/D,CAAjC;AAIA,YAAIwI,wBAAwB,GAAGvJ,aAAa,CAACL,yBAAd,CAAwC2J,mBAAxC,CAA4D;AACzFJ,UAAAA,aAAa,EAAEpG,MAD0E;AAEzFqG,UAAAA,MAAM,EAAEnI;AAFiF,SAA5D,CAA/B,CAd2B,CAmB3B;;AACA,aAAKhE,yBAAL,GAAiCgM,oBAAoB,CAACQ,KAAtD;AACA,aAAKvM,wBAAL,GAAgC+L,oBAAoB,CAACS,IAArD;AACA,aAAKvM,sBAAL,GAA8BkM,iBAAiB,CAACI,KAAhD;AACA,aAAKrM,qBAAL,GAA6BiM,iBAAiB,CAACK,IAA/C;AAEA,YAAIC,qBAAqB,GAAGb,qBAAqB,CAAC;AAChDvB,UAAAA,SAAS,EAAE,YADqC;AAEhDnI,UAAAA,SAAS,EAAEC,WAFqC;AAGhDuK,UAAAA,kBAAkB,EAAEf,mBAH4B;AAIhDgB,UAAAA,eAAe,EAAEhJ,yBAJ+B;AAKhDiJ,UAAAA,UAAU,EAAE,OAAOb,oBAAoB,CAACQ,KAA5B,KAAsC,QAAtC,GAAiDR,oBAAoB,CAACQ,KAAtE,GAA8E,CAL1C;AAMhDM,UAAAA,SAAS,EAAE,OAAOd,oBAAoB,CAACS,IAA5B,KAAqC,QAArC,GAAgDT,oBAAoB,CAACS,IAArE,GAA4E,CAAC;AANxC,SAAD,CAAjD;AASA,YAAIM,kBAAkB,GAAGlB,qBAAqB,CAAC;AAC7CvB,UAAAA,SAAS,EAAE,UADkC;AAE7CnI,UAAAA,SAAS,EAAES,QAFkC;AAG7C+J,UAAAA,kBAAkB,EAAEb,gBAHyB;AAI7Cc,UAAAA,eAAe,EAAE9I,uBAJ4B;AAK7C+I,UAAAA,UAAU,EAAE,OAAOT,iBAAiB,CAACI,KAAzB,KAAmC,QAAnC,GAA8CJ,iBAAiB,CAACI,KAAhE,GAAwE,CALvC;AAM7CM,UAAAA,SAAS,EAAE,OAAOV,iBAAiB,CAACK,IAAzB,KAAkC,QAAlC,GAA6CL,iBAAiB,CAACK,IAA/D,GAAsE,CAAC;AANrC,SAAD,CAA9C,CAlC2B,CA2C3B;;AACA,YAAItL,gBAAgB,GAAGuL,qBAAqB,CAACM,kBAA7C;AACA,YAAI5L,eAAe,GAAGsL,qBAAqB,CAACO,iBAA5C;AACA,YAAIxL,aAAa,GAAGsL,kBAAkB,CAACC,kBAAvC;AACA,YAAItL,YAAY,GAAGqL,kBAAkB,CAACE,iBAAtC,CA/C2B,CAiD3B;;AACA,YAAItB,wBAAJ,EAA8B;AAC5B;AACA;AACA;AACA;AACA,cAAI,CAACA,wBAAwB,CAACuB,cAAzB,EAAL,EAAgD;AAC9C,iBAAK,IAAIlI,QAAQ,GAAGvD,aAApB,EAAmCuD,QAAQ,IAAItD,YAA/C,EAA6DsD,QAAQ,EAArE,EAAyE;AACvE,kBAAI,CAAC2G,wBAAwB,CAACwB,GAAzB,CAA6BnI,QAA7B,EAAuC,CAAvC,CAAL,EAAgD;AAC9C7D,gBAAAA,gBAAgB,GAAG,CAAnB;AACAC,gBAAAA,eAAe,GAAGgB,WAAW,GAAG,CAAhC;AACA;AACD;AACF;AACF,WAb2B,CAe5B;AACA;AACA;AACA;;;AACA,cAAI,CAACuJ,wBAAwB,CAACyB,aAAzB,EAAL,EAA+C;AAC7C,iBAAK,IAAItI,WAAW,GAAG3D,gBAAvB,EAAyC2D,WAAW,IAAI1D,eAAxD,EAAyE0D,WAAW,EAApF,EAAwF;AACtF,kBAAI,CAAC6G,wBAAwB,CAACwB,GAAzB,CAA6B,CAA7B,EAAgCrI,WAAhC,CAAL,EAAmD;AACjDrD,gBAAAA,aAAa,GAAG,CAAhB;AACAC,gBAAAA,YAAY,GAAGkB,QAAQ,GAAG,CAA1B;AACA;AACD;AACF;AACF;AACF;;AAED,aAAKqI,kBAAL,GAA0BS,iBAAiB,CAAC;AAC1C2B,UAAAA,SAAS,EAAE,KAAKhN,UAD0B;AAE1CoL,UAAAA,YAAY,EAAEA,YAF4B;AAG1CvJ,UAAAA,4BAA4B,EAAEc,aAAa,CAACd,4BAHF;AAI1Cf,UAAAA,gBAAgB,EAAEA,gBAJwB;AAK1CC,UAAAA,eAAe,EAAEA,eALyB;AAM1CuK,UAAAA,wBAAwB,EAAEA,wBANgB;AAO1CU,UAAAA,0BAA0B,EAAEA,0BAPc;AAQ1C5L,UAAAA,WAAW,EAAEA,WAR6B;AAS1CsL,UAAAA,iBAAiB,EAAEA,iBATuB;AAU1CuB,UAAAA,MAAM,EAAE,IAVkC;AAW1C3K,UAAAA,yBAAyB,EAAEK,aAAa,CAACL,yBAXC;AAY1ClB,UAAAA,aAAa,EAAEA,aAZ2B;AAa1CC,UAAAA,YAAY,EAAEA,YAb4B;AAc1CqC,UAAAA,UAAU,EAAEA,UAd8B;AAe1CC,UAAAA,SAAS,EAAEA,SAf+B;AAgB1CuJ,UAAAA,UAAU,EAAE,KAAKnN,WAhByB;AAiB1CmM,UAAAA,wBAAwB,EAAEA,wBAjBgB;AAkB1CP,UAAAA,oBAAoB,EAAEA,oBAlBoB;AAmB1CI,UAAAA,iBAAiB,EAAEA;AAnBuB,SAAD,CAA3C,CAhF2B,CAsG3B;;AACA,aAAKpL,iBAAL,GAAyBG,gBAAzB;AACA,aAAKD,gBAAL,GAAwBE,eAAxB;AACA,aAAKE,cAAL,GAAsBG,aAAtB;AACA,aAAKD,aAAL,GAAqBE,YAArB;AACD;AACF;AAED;;;;;;AA3IC,GAriB8B,EAsrB9B;AACDjD,IAAAA,GAAG,EAAE,sBADJ;AAED9C,IAAAA,KAAK,EAAE,SAAS+J,oBAAT,GAAgC;AACrC,UAAI8H,0BAA0B,GAAG,KAAKpO,KAAL,CAAWoO,0BAA5C;;AAGA,UAAI,KAAKjN,8BAAT,EAAyC;AACvC,SAAC,GAAGrC,wBAAwB,CAACmL,sBAA7B,EAAqD,KAAK9I,8BAA1D;AACD;;AAED,WAAKA,8BAAL,GAAsC,CAAC,GAAGrC,wBAAwB,CAACuP,uBAA7B,EAAsD,KAAKnN,4BAA3D,EAAyFkN,0BAAzF,CAAtC;AACD;AAXA,GAtrB8B,EAksB9B;AACD/O,IAAAA,GAAG,EAAE,4BADJ;;AAID;;;;AAIA9C,IAAAA,KAAK,EAAE,SAASkM,0BAAT,GAAsC;AAC3C,UAAI,OAAO,KAAKpI,8BAAZ,KAA+C,QAA/C,IAA2D,OAAO,KAAKC,2BAAZ,KAA4C,QAA3G,EAAqH;AACnH,YAAIoF,WAAW,GAAG,KAAKrF,8BAAvB;AACA,YAAIuF,QAAQ,GAAG,KAAKtF,2BAApB;AAEA,aAAKD,8BAAL,GAAsC,IAAtC;AACA,aAAKC,2BAAL,GAAmC,IAAnC;AAEA,aAAKqH,iBAAL,CAAuB;AAAEjC,UAAAA,WAAW,EAAEA,WAAf;AAA4BE,UAAAA,QAAQ,EAAEA;AAAtC,SAAvB;AACD;AACF;AAlBA,GAlsB8B,EAqtB9B;AACDvG,IAAAA,GAAG,EAAE,yBADJ;AAED9C,IAAAA,KAAK,EAAE,SAAS8K,uBAAT,CAAiCiH,KAAjC,EAAwC;AAC7C,UAAIC,MAAM,GAAG,IAAb;;AAEA,UAAI5J,UAAU,GAAG2J,KAAK,CAAC3J,UAAvB;AAAA,UACIC,SAAS,GAAG0J,KAAK,CAAC1J,SADtB;AAAA,UAEIiC,iBAAiB,GAAGyH,KAAK,CAACzH,iBAF9B;AAAA,UAGID,eAAe,GAAG0H,KAAK,CAAC1H,eAH5B;;AAKA,WAAKxG,iBAAL,CAAuB;AACrBqB,QAAAA,QAAQ,EAAE,SAASA,QAAT,CAAkB+M,KAAlB,EAAyB;AACjC,cAAI7J,UAAU,GAAG6J,KAAK,CAAC7J,UAAvB;AAAA,cACIC,SAAS,GAAG4J,KAAK,CAAC5J,SADtB;AAEA,cAAI6J,OAAO,GAAGF,MAAM,CAACvO,KAArB;AAAA,cACI0G,MAAM,GAAG+H,OAAO,CAAC/H,MADrB;AAAA,cAEIsF,QAAQ,GAAGyC,OAAO,CAACzC,QAFvB;AAAA,cAGIrF,KAAK,GAAG8H,OAAO,CAAC9H,KAHpB;AAMAqF,UAAAA,QAAQ,CAAC;AACP0C,YAAAA,YAAY,EAAEhI,MADP;AAEPiI,YAAAA,WAAW,EAAEhI,KAFN;AAGPiI,YAAAA,YAAY,EAAEhI,eAHP;AAIPjC,YAAAA,UAAU,EAAEA,UAJL;AAKPC,YAAAA,SAAS,EAAEA,SALJ;AAMPiK,YAAAA,WAAW,EAAEhI;AANN,WAAD,CAAR;AAQD,SAlBoB;AAmBrBnF,QAAAA,OAAO,EAAE;AACPiD,UAAAA,UAAU,EAAEA,UADL;AAEPC,UAAAA,SAAS,EAAEA;AAFJ;AAnBY,OAAvB;AAwBD;AAlCA,GArtB8B,EAwvB9B;AACDvF,IAAAA,GAAG,EAAE,cADJ;AAED9C,IAAAA,KAAK,EAAE,SAASwO,YAAT,GAAwB;AAC7B,UAAI/K,KAAK,GAAGoF,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiB3I,SAAzC,GAAqD2I,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAKpF,KAArF;AACA,UAAI2D,KAAK,GAAGyB,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiB3I,SAAzC,GAAqD2I,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAKzB,KAArF,CAF6B,CAI7B;AACA;;AACA,aAAOvH,MAAM,CAACmD,cAAP,CAAsBC,IAAtB,CAA2BQ,KAA3B,EAAkC,aAAlC,IAAmD8O,OAAO,CAAC9O,KAAK,CAACqB,WAAP,CAA1D,GAAgFyN,OAAO,CAACnL,KAAK,CAACtC,WAAP,CAA9F;AACD;AATA,GAxvB8B,EAkwB9B;AACDhC,IAAAA,GAAG,EAAE,qCADJ;AAED9C,IAAAA,KAAK,EAAE,SAASuM,mCAAT,GAA+C;AACpD,UAAI,KAAKnI,yBAAT,EAAoC;AAClC,YAAIoO,0BAA0B,GAAG,KAAK/O,KAAL,CAAWgP,yBAA5C;AAGA,aAAKrO,yBAAL,GAAiC,KAAjC;;AAEAoO,QAAAA,0BAA0B,CAAC;AACzBE,UAAAA,UAAU,EAAE,KAAKxO,wBAAL,GAAgC,CADnB;AAEzBqJ,UAAAA,IAAI,EAAE,KAAKnG,KAAL,CAAWC,aAAX,CAAyBU,aAFN;AAGzB4K,UAAAA,QAAQ,EAAE,KAAKxO,sBAAL,GAA8B;AAHf,SAAD,CAA1B;AAKD;AACF;AAfA,GAlwB8B,EAkxB9B;AACDrB,IAAAA,GAAG,EAAE,kBADJ;;AAID;;;;AAIA9C,IAAAA,KAAK,EAAE,SAAS4S,gBAAT,CAA0BC,KAA1B,EAAiC;AACtC,UAAIzK,UAAU,GAAGyK,KAAK,CAACzK,UAAvB;AAAA,UACIC,SAAS,GAAGwK,KAAK,CAACxK,SADtB;;AAGA,UAAI+D,WAAW,GAAG7I,IAAI,CAAC8I,+BAAL,CAAqC;AACrDF,QAAAA,SAAS,EAAE,KAAK/E,KADqC;AAErDgB,QAAAA,UAAU,EAAEA,UAFyC;AAGrDC,QAAAA,SAAS,EAAEA;AAH0C,OAArC,CAAlB;;AAMA,UAAI+D,WAAJ,EAAiB;AACfA,QAAAA,WAAW,CAACrH,qBAAZ,GAAoC,KAApC;AACA,aAAKF,QAAL,CAAcuH,WAAd;AACD;AACF;AAtBA,GAlxB8B,EAyyB9B;AACDtJ,IAAAA,GAAG,EAAE,0BADJ;AAED9C,IAAAA,KAAK,EAAE,SAAS0I,wBAAT,GAAoC;AACzC,UAAIjF,KAAK,GAAGoF,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiB3I,SAAzC,GAAqD2I,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAKpF,KAArF;AACA,UAAI2D,KAAK,GAAGyB,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiB3I,SAAzC,GAAqD2I,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAKzB,KAArF;AAEA,aAAO7D,IAAI,CAACmF,wBAAL,CAA8BjF,KAA9B,EAAqC2D,KAArC,CAAP;AACD;AAPA,GAzyB8B,EAizB9B;AACDtE,IAAAA,GAAG,EAAE,oCADJ;AAED9C,IAAAA,KAAK,EAAE,SAAS6L,kCAAT,GAA8C;AACnD,UAAIpI,KAAK,GAAGoF,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiB3I,SAAzC,GAAqD2I,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAKpF,KAArF;AACA,UAAI2D,KAAK,GAAGyB,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiB3I,SAAzC,GAAqD2I,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAKzB,KAArF;;AAEA,UAAIgF,WAAW,GAAG7I,IAAI,CAACuP,0CAAL,CAAgDrP,KAAhD,EAAuD2D,KAAvD,CAAlB;;AACA,UAAIgF,WAAJ,EAAiB;AACfA,QAAAA,WAAW,CAACrH,qBAAZ,GAAoC,KAApC;AACA,aAAKF,QAAL,CAAcuH,WAAd;AACD;AACF;AAXA,GAjzB8B,EA6zB9B;AACDtJ,IAAAA,GAAG,EAAE,yBADJ;AAED9C,IAAAA,KAAK,EAAE,SAASwI,uBAAT,GAAmC;AACxC,UAAI/E,KAAK,GAAGoF,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiB3I,SAAzC,GAAqD2I,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAKpF,KAArF;AACA,UAAI2D,KAAK,GAAGyB,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiB3I,SAAzC,GAAqD2I,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAKzB,KAArF;AAEA,aAAO7D,IAAI,CAACiF,uBAAL,CAA6B/E,KAA7B,EAAoC2D,KAApC,CAAP;AACD;AAPA,GA7zB8B,EAq0B9B;AACDtE,IAAAA,GAAG,EAAE,kBADJ;AAED9C,IAAAA,KAAK,EAAE,SAAS+O,gBAAT,GAA4B;AACjC,UAAI6C,UAAU,GAAG,KAAKnN,WAAtB;AACA,UAAIiN,SAAS,GAAG,KAAKhN,UAArB;AACA,UAAI0L,iBAAiB,GAAG,KAAK3M,KAAL,CAAW2M,iBAAnC,CAHiC,CAKjC;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAK1L,UAAL,GAAkB,EAAlB;AACA,WAAKD,WAAL,GAAmB,EAAnB,CAbiC,CAejC;;AACA,WAAK,IAAI4E,QAAQ,GAAG,KAAK1D,cAAzB,EAAyC0D,QAAQ,IAAI,KAAKxD,aAA1D,EAAyEwD,QAAQ,EAAjF,EAAqF;AACnF,aAAK,IAAIF,WAAW,GAAG,KAAK9D,iBAA5B,EAA+C8D,WAAW,IAAI,KAAK5D,gBAAnE,EAAqF4D,WAAW,EAAhG,EAAoG;AAClG,cAAIrG,GAAG,GAAGuG,QAAQ,GAAG,GAAX,GAAiBF,WAA3B;AACA,eAAK1E,WAAL,CAAiB3B,GAAjB,IAAwB8O,UAAU,CAAC9O,GAAD,CAAlC;;AAEA,cAAIsN,iBAAJ,EAAuB;AACrB,iBAAK1L,UAAL,CAAgB5B,GAAhB,IAAuB4O,SAAS,CAAC5O,GAAD,CAAhC;AACD;AACF;AACF;AACF;AA5BA,GAr0B8B,EAk2B9B;AACDA,IAAAA,GAAG,EAAE,gCADJ;AAED9C,IAAAA,KAAK,EAAE,SAAS8L,8BAAT,GAA0C;AAC/C,UAAIrI,KAAK,GAAGoF,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiB3I,SAAzC,GAAqD2I,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAKpF,KAArF;AACA,UAAI2D,KAAK,GAAGyB,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiB3I,SAAzC,GAAqD2I,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAKzB,KAArF;;AAEA,UAAIgF,WAAW,GAAG7I,IAAI,CAACwP,sCAAL,CAA4CtP,KAA5C,EAAmD2D,KAAnD,CAAlB;;AACA,UAAIgF,WAAJ,EAAiB;AACfA,QAAAA,WAAW,CAACrH,qBAAZ,GAAoC,KAApC;AACA,aAAKF,QAAL,CAAcuH,WAAd;AACD;AACF;AAXA,GAl2B8B,CAAjC,EA82BI,CAAC;AACHtJ,IAAAA,GAAG,EAAE,0BADF;AAEH9C,IAAAA,KAAK,EAAE,SAASgT,wBAAT,CAAkCC,SAAlC,EAA6C9G,SAA7C,EAAwD;AAC7D,UAAItB,QAAQ,GAAG,EAAf;;AAEA,UAAIoI,SAAS,CAACxM,WAAV,KAA0B,CAA1B,IAA+B0F,SAAS,CAAC/D,UAAV,KAAyB,CAAxD,IAA6D6K,SAAS,CAAChM,QAAV,KAAuB,CAAvB,IAA4BkF,SAAS,CAAC9D,SAAV,KAAwB,CAArH,EAAwH;AACtHwC,QAAAA,QAAQ,CAACzC,UAAT,GAAsB,CAAtB;AACAyC,QAAAA,QAAQ,CAACxC,SAAT,GAAqB,CAArB,CAFsH,CAItH;AACA;AACD,OAND,MAMO,IAAI4K,SAAS,CAAC7K,UAAV,KAAyB+D,SAAS,CAAC/D,UAAnC,IAAiD6K,SAAS,CAACrL,cAAV,GAA2B,CAA5E,IAAiFqL,SAAS,CAAC5K,SAAV,KAAwB8D,SAAS,CAAC9D,SAAlC,IAA+C4K,SAAS,CAACnL,WAAV,GAAwB,CAA5J,EAA+J;AACpK,SAAC,GAAGzH,QAAQ,CAAC6C,OAAb,EAAsB2H,QAAtB,EAAgCtH,IAAI,CAAC8I,+BAAL,CAAqC;AACnEF,UAAAA,SAAS,EAAEA,SADwD;AAEnE/D,UAAAA,UAAU,EAAE6K,SAAS,CAAC7K,UAF6C;AAGnEC,UAAAA,SAAS,EAAE4K,SAAS,CAAC5K;AAH8C,SAArC,CAAhC;AAKD;;AAED,UAAIhB,aAAa,GAAG8E,SAAS,CAAC9E,aAA9B,CAjB6D,CAmB7D;;AAEAwD,MAAAA,QAAQ,CAAC9F,qBAAT,GAAiC,KAAjC;;AACA,UAAIkO,SAAS,CAACpM,WAAV,KAA0BQ,aAAa,CAACC,eAAxC,IAA2D2L,SAAS,CAAC/L,SAAV,KAAwBG,aAAa,CAACE,aAArG,EAAoH;AAClH;AACAsD,QAAAA,QAAQ,CAAC9F,qBAAT,GAAiC,IAAjC;AACD;;AAEDsC,MAAAA,aAAa,CAACd,4BAAd,CAA2C2M,SAA3C,CAAqD;AACnD1M,QAAAA,SAAS,EAAEyM,SAAS,CAACxM,WAD8B;AAEnDK,QAAAA,iBAAiB,EAAEvD,IAAI,CAACwD,uBAAL,CAA6BkM,SAA7B,CAFgC;AAGnDvM,QAAAA,cAAc,EAAEnD,IAAI,CAACqD,eAAL,CAAqBqM,SAAS,CAACpM,WAA/B;AAHmC,OAArD;AAMAQ,MAAAA,aAAa,CAACL,yBAAd,CAAwCkM,SAAxC,CAAkD;AAChD1M,QAAAA,SAAS,EAAEyM,SAAS,CAAChM,QAD2B;AAEhDH,QAAAA,iBAAiB,EAAEvD,IAAI,CAAC4D,oBAAL,CAA0B8L,SAA1B,CAF6B;AAGhDvM,QAAAA,cAAc,EAAEnD,IAAI,CAACqD,eAAL,CAAqBqM,SAAS,CAAC/L,SAA/B;AAHgC,OAAlD;;AAMA,UAAIG,aAAa,CAACG,eAAd,KAAkC,CAAlC,IAAuCH,aAAa,CAACI,YAAd,KAA+B,CAA1E,EAA6E;AAC3EJ,QAAAA,aAAa,CAACG,eAAd,GAAgC,CAAhC;AACAH,QAAAA,aAAa,CAACI,YAAd,GAA6B,CAA7B;AACD,OA1C4D,CA4C7D;;;AACA,UAAIwL,SAAS,CAAChJ,UAAV,IAAwBgJ,SAAS,CAACnO,WAAV,KAA0B,KAAlD,IAA2DuC,aAAa,CAACK,eAAd,KAAkC,IAAjG,EAAuG;AACrG,SAAC,GAAGrH,QAAQ,CAAC6C,OAAb,EAAsB2H,QAAtB,EAAgC;AAC9B/F,UAAAA,WAAW,EAAE;AADiB,SAAhC;AAGD;;AAED,UAAIqO,WAAW,GAAG,KAAK,CAAvB;AACA,UAAIC,WAAW,GAAG,KAAK,CAAvB;AAEA,OAAC,GAAG3R,mDAAmD,CAACyB,OAAxD,EAAiE;AAC/DsD,QAAAA,SAAS,EAAEa,aAAa,CAACG,eADsC;AAE/D6L,QAAAA,QAAQ,EAAE,OAAOhM,aAAa,CAACC,eAArB,KAAyC,QAAzC,GAAoDD,aAAa,CAACC,eAAlE,GAAoF,IAF/B;AAG/DgM,QAAAA,uBAAuB,EAAE,SAASA,uBAAT,GAAmC;AAC1D,iBAAOjM,aAAa,CAACd,4BAAd,CAA2CkF,SAA3C,CAAqD,CAArD,CAAP;AACD,SAL8D;AAM/D8H,QAAAA,4BAA4B,EAAEN,SANiC;AAO/DO,QAAAA,cAAc,EAAEP,SAAS,CAACxM,WAPqC;AAQ/DgN,QAAAA,YAAY,EAAE,OAAOR,SAAS,CAACpM,WAAjB,KAAiC,QAAjC,GAA4CoM,SAAS,CAACpM,WAAtD,GAAoE,IARnB;AAS/D6M,QAAAA,iBAAiB,EAAET,SAAS,CAACrL,cATkC;AAU/D0F,QAAAA,aAAa,EAAEjG,aAAa,CAACM,kBAVkC;AAW/DgM,QAAAA,kCAAkC,EAAE,SAASA,kCAAT,GAA8C;AAChFR,UAAAA,WAAW,GAAG5P,IAAI,CAACuP,0CAAL,CAAgDG,SAAhD,EAA2D9G,SAA3D,CAAd;AACD;AAb8D,OAAjE;AAeA,OAAC,GAAG1K,mDAAmD,CAACyB,OAAxD,EAAiE;AAC/DsD,QAAAA,SAAS,EAAEa,aAAa,CAACI,YADsC;AAE/D4L,QAAAA,QAAQ,EAAE,OAAOhM,aAAa,CAACE,aAArB,KAAuC,QAAvC,GAAkDF,aAAa,CAACE,aAAhE,GAAgF,IAF3B;AAG/D+L,QAAAA,uBAAuB,EAAE,SAASA,uBAAT,GAAmC;AAC1D,iBAAOjM,aAAa,CAACL,yBAAd,CAAwCyE,SAAxC,CAAkD,CAAlD,CAAP;AACD,SAL8D;AAM/D8H,QAAAA,4BAA4B,EAAEN,SANiC;AAO/DO,QAAAA,cAAc,EAAEP,SAAS,CAAChM,QAPqC;AAQ/DwM,QAAAA,YAAY,EAAE,OAAOR,SAAS,CAAC/L,SAAjB,KAA+B,QAA/B,GAA0C+L,SAAS,CAAC/L,SAApD,GAAgE,IARf;AAS/DwM,QAAAA,iBAAiB,EAAET,SAAS,CAACnL,WATkC;AAU/DwF,QAAAA,aAAa,EAAEjG,aAAa,CAACQ,eAVkC;AAW/D8L,QAAAA,kCAAkC,EAAE,SAASA,kCAAT,GAA8C;AAChFP,UAAAA,WAAW,GAAG7P,IAAI,CAACwP,sCAAL,CAA4CE,SAA5C,EAAuD9G,SAAvD,CAAd;AACD;AAb8D,OAAjE;AAgBA9E,MAAAA,aAAa,CAACG,eAAd,GAAgCyL,SAAS,CAACxM,WAA1C;AACAY,MAAAA,aAAa,CAACC,eAAd,GAAgC2L,SAAS,CAACpM,WAA1C;AACAQ,MAAAA,aAAa,CAACK,eAAd,GAAgCuL,SAAS,CAACnO,WAAV,KAA0B,IAA1D;AACAuC,MAAAA,aAAa,CAACI,YAAd,GAA6BwL,SAAS,CAAChM,QAAvC;AACAI,MAAAA,aAAa,CAACE,aAAd,GAA8B0L,SAAS,CAAC/L,SAAxC;AACAG,MAAAA,aAAa,CAACM,kBAAd,GAAmCsL,SAAS,CAACrL,cAA7C;AACAP,MAAAA,aAAa,CAACQ,eAAd,GAAgCoL,SAAS,CAACnL,WAA1C,CA3F6D,CA6F7D;;AACAT,MAAAA,aAAa,CAACU,aAAd,GAA8BkL,SAAS,CAAChH,gBAAV,EAA9B;;AACA,UAAI5E,aAAa,CAACU,aAAd,KAAgC7H,SAApC,EAA+C;AAC7CmH,QAAAA,aAAa,CAACW,qBAAd,GAAsC,KAAtC;AACAX,QAAAA,aAAa,CAACU,aAAd,GAA8B,CAA9B;AACD,OAHD,MAGO;AACLV,QAAAA,aAAa,CAACW,qBAAd,GAAsC,IAAtC;AACD;;AAED6C,MAAAA,QAAQ,CAACxD,aAAT,GAAyBA,aAAzB;AAEA,aAAO,CAAC,GAAG7G,SAAS,CAAC0C,OAAd,EAAuB,EAAvB,EAA2B2H,QAA3B,EAAqCsI,WAArC,EAAkDC,WAAlD,CAAP;AACD;AA3GE,GAAD,EA4GD;AACDtQ,IAAAA,GAAG,EAAE,yBADJ;AAED9C,IAAAA,KAAK,EAAE,SAAS+G,uBAAT,CAAiCtD,KAAjC,EAAwC;AAC7C,aAAO,OAAOA,KAAK,CAACoD,WAAb,KAA6B,QAA7B,GAAwCpD,KAAK,CAACoD,WAA9C,GAA4DpD,KAAK,CAACmQ,mBAAzE;AACD;AAJA,GA5GC,EAiHD;AACD9Q,IAAAA,GAAG,EAAE,sBADJ;AAED9C,IAAAA,KAAK,EAAE,SAASmH,oBAAT,CAA8B1D,KAA9B,EAAqC;AAC1C,aAAO,OAAOA,KAAK,CAACyD,SAAb,KAA2B,QAA3B,GAAsCzD,KAAK,CAACyD,SAA5C,GAAwDzD,KAAK,CAACoQ,gBAArE;AACD;AAJA,GAjHC,EAsHD;AACD/Q,IAAAA,GAAG,EAAE,iCADJ;;AAID;;;;AAIA9C,IAAAA,KAAK,EAAE,SAASqM,+BAAT,CAAyCyH,KAAzC,EAAgD;AACrD,UAAI3H,SAAS,GAAG2H,KAAK,CAAC3H,SAAtB;AAAA,UACI/D,UAAU,GAAG0L,KAAK,CAAC1L,UADvB;AAAA,UAEIC,SAAS,GAAGyL,KAAK,CAACzL,SAFtB;AAIA,UAAIwC,QAAQ,GAAG;AACbvC,QAAAA,0BAA0B,EAAEnF,8BAA8B,CAACE;AAD9C,OAAf;;AAIA,UAAI,OAAO+E,UAAP,KAAsB,QAAtB,IAAkCA,UAAU,IAAI,CAApD,EAAuD;AACrDyC,QAAAA,QAAQ,CAAC5C,yBAAT,GAAqCG,UAAU,GAAG+D,SAAS,CAAC/D,UAAvB,GAAoCtG,6BAA6B,CAACoG,wBAAlE,GAA6FpG,6BAA6B,CAAC6I,yBAAhK;AACAE,QAAAA,QAAQ,CAACzC,UAAT,GAAsBA,UAAtB;AACD;;AAED,UAAI,OAAOC,SAAP,KAAqB,QAArB,IAAiCA,SAAS,IAAI,CAAlD,EAAqD;AACnDwC,QAAAA,QAAQ,CAAC1C,uBAAT,GAAmCE,SAAS,GAAG8D,SAAS,CAAC9D,SAAtB,GAAkCvG,6BAA6B,CAACoG,wBAAhE,GAA2FpG,6BAA6B,CAAC6I,yBAA5J;AACAE,QAAAA,QAAQ,CAACxC,SAAT,GAAqBA,SAArB;AACD;;AAED,UAAI,OAAOD,UAAP,KAAsB,QAAtB,IAAkCA,UAAU,IAAI,CAAhD,IAAqDA,UAAU,KAAK+D,SAAS,CAAC/D,UAA9E,IAA4F,OAAOC,SAAP,KAAqB,QAArB,IAAiCA,SAAS,IAAI,CAA9C,IAAmDA,SAAS,KAAK8D,SAAS,CAAC9D,SAA3K,EAAsL;AACpL,eAAOwC,QAAP;AACD;;AACD,aAAO,IAAP;AACD;AA/BA,GAtHC,EAsJD;AACD/H,IAAAA,GAAG,EAAE,iBADJ;AAED9C,IAAAA,KAAK,EAAE,SAAS4G,eAAT,CAAyB5G,KAAzB,EAAgC;AACrC,aAAO,OAAOA,KAAP,KAAiB,UAAjB,GAA8BA,KAA9B,GAAsC,YAAY;AACvD,eAAOA,KAAP;AACD,OAFD;AAGD;AANA,GAtJC,EA6JD;AACD8C,IAAAA,GAAG,EAAE,0BADJ;AAED9C,IAAAA,KAAK,EAAE,SAAS0I,wBAAT,CAAkCuK,SAAlC,EAA6C9G,SAA7C,EAAwD;AAC7D,UAAI1F,WAAW,GAAGwM,SAAS,CAACxM,WAA5B;AAAA,UACI0D,MAAM,GAAG8I,SAAS,CAAC9I,MADvB;AAAA,UAEIlB,iBAAiB,GAAGgK,SAAS,CAAChK,iBAFlC;AAAA,UAGIrB,cAAc,GAAGqL,SAAS,CAACrL,cAH/B;AAAA,UAIIwC,KAAK,GAAG6I,SAAS,CAAC7I,KAJtB;AAKA,UAAIhC,UAAU,GAAG+D,SAAS,CAAC/D,UAA3B;AAAA,UACIf,aAAa,GAAG8E,SAAS,CAAC9E,aAD9B;;AAIA,UAAIZ,WAAW,GAAG,CAAlB,EAAqB;AACnB,YAAIsN,WAAW,GAAGtN,WAAW,GAAG,CAAhC;AACA,YAAIuN,WAAW,GAAGpM,cAAc,GAAG,CAAjB,GAAqBmM,WAArB,GAAmCxJ,IAAI,CAACC,GAAL,CAASuJ,WAAT,EAAsBnM,cAAtB,CAArD;AACA,YAAIyC,eAAe,GAAGhD,aAAa,CAACL,yBAAd,CAAwCwC,YAAxC,EAAtB;AACA,YAAIyK,aAAa,GAAG5M,aAAa,CAACW,qBAAd,IAAuCqC,eAAe,GAAGF,MAAzD,GAAkE9C,aAAa,CAACU,aAAhF,GAAgG,CAApH;AAEA,eAAOV,aAAa,CAACd,4BAAd,CAA2C2N,wBAA3C,CAAoE;AACzEC,UAAAA,KAAK,EAAElL,iBADkE;AAEzEsH,UAAAA,aAAa,EAAEnG,KAAK,GAAG6J,aAFkD;AAGzEG,UAAAA,aAAa,EAAEhM,UAH0D;AAIzE4L,UAAAA,WAAW,EAAEA;AAJ4D,SAApE,CAAP;AAMD;;AACD,aAAO,CAAP;AACD;AA1BA,GA7JC,EAwLD;AACDlR,IAAAA,GAAG,EAAE,4CADJ;AAED9C,IAAAA,KAAK,EAAE,SAAS8S,0CAAT,CAAoDG,SAApD,EAA+D9G,SAA/D,EAA0E;AAC/E,UAAI/D,UAAU,GAAG+D,SAAS,CAAC/D,UAA3B;;AAEA,UAAIiM,oBAAoB,GAAG9Q,IAAI,CAACmF,wBAAL,CAA8BuK,SAA9B,EAAyC9G,SAAzC,CAA3B;;AAEA,UAAI,OAAOkI,oBAAP,KAAgC,QAAhC,IAA4CA,oBAAoB,IAAI,CAApE,IAAyEjM,UAAU,KAAKiM,oBAA5F,EAAkH;AAChH,eAAO9Q,IAAI,CAAC8I,+BAAL,CAAqC;AAC1CF,UAAAA,SAAS,EAAEA,SAD+B;AAE1C/D,UAAAA,UAAU,EAAEiM,oBAF8B;AAG1ChM,UAAAA,SAAS,EAAE,CAAC;AAH8B,SAArC,CAAP;AAKD;;AACD,aAAO,IAAP;AACD;AAfA,GAxLC,EAwMD;AACDvF,IAAAA,GAAG,EAAE,yBADJ;AAED9C,IAAAA,KAAK,EAAE,SAASwI,uBAAT,CAAiCyK,SAAjC,EAA4C9G,SAA5C,EAAuD;AAC5D,UAAIhC,MAAM,GAAG8I,SAAS,CAAC9I,MAAvB;AAAA,UACIlD,QAAQ,GAAGgM,SAAS,CAAChM,QADzB;AAAA,UAEIgC,iBAAiB,GAAGgK,SAAS,CAAChK,iBAFlC;AAAA,UAGInB,WAAW,GAAGmL,SAAS,CAACnL,WAH5B;AAAA,UAIIsC,KAAK,GAAG6I,SAAS,CAAC7I,KAJtB;AAKA,UAAI/B,SAAS,GAAG8D,SAAS,CAAC9D,SAA1B;AAAA,UACIhB,aAAa,GAAG8E,SAAS,CAAC9E,aAD9B;;AAIA,UAAIJ,QAAQ,GAAG,CAAf,EAAkB;AAChB,YAAIqN,QAAQ,GAAGrN,QAAQ,GAAG,CAA1B;AACA,YAAI+M,WAAW,GAAGlM,WAAW,GAAG,CAAd,GAAkBwM,QAAlB,GAA6B/J,IAAI,CAACC,GAAL,CAAS8J,QAAT,EAAmBxM,WAAnB,CAA/C;AACA,YAAIwC,iBAAiB,GAAGjD,aAAa,CAACd,4BAAd,CAA2CiD,YAA3C,EAAxB;AACA,YAAIyK,aAAa,GAAG5M,aAAa,CAACW,qBAAd,IAAuCsC,iBAAiB,GAAGF,KAA3D,GAAmE/C,aAAa,CAACU,aAAjF,GAAiG,CAArH;AAEA,eAAOV,aAAa,CAACL,yBAAd,CAAwCkN,wBAAxC,CAAiE;AACtEC,UAAAA,KAAK,EAAElL,iBAD+D;AAEtEsH,UAAAA,aAAa,EAAEpG,MAAM,GAAG8J,aAF8C;AAGtEG,UAAAA,aAAa,EAAE/L,SAHuD;AAItE2L,UAAAA,WAAW,EAAEA;AAJyD,SAAjE,CAAP;AAMD;;AACD,aAAO,CAAP;AACD;AA1BA,GAxMC,EAmOD;AACDlR,IAAAA,GAAG,EAAE,wCADJ;AAED9C,IAAAA,KAAK,EAAE,SAAS+S,sCAAT,CAAgDE,SAAhD,EAA2D9G,SAA3D,EAAsE;AAC3E,UAAI9D,SAAS,GAAG8D,SAAS,CAAC9D,SAA1B;;AAEA,UAAIkM,mBAAmB,GAAGhR,IAAI,CAACiF,uBAAL,CAA6ByK,SAA7B,EAAwC9G,SAAxC,CAA1B;;AAEA,UAAI,OAAOoI,mBAAP,KAA+B,QAA/B,IAA2CA,mBAAmB,IAAI,CAAlE,IAAuElM,SAAS,KAAKkM,mBAAzF,EAA8G;AAC5G,eAAOhR,IAAI,CAAC8I,+BAAL,CAAqC;AAC1CF,UAAAA,SAAS,EAAEA,SAD+B;AAE1C/D,UAAAA,UAAU,EAAE,CAAC,CAF6B;AAG1CC,UAAAA,SAAS,EAAEkM;AAH+B,SAArC,CAAP;AAKD;;AACD,aAAO,IAAP;AACD;AAfA,GAnOC,CA92BJ;AAkmCA,SAAOhR,IAAP;AACD,CA5tCU,CA4tCTnC,KAAK,CAACoT,aA5tCG,CAAX;;AA8tCAjR,IAAI,CAACkR,YAAL,GAAoB;AAClB,gBAAc,MADI;AAElB,mBAAiB,IAFC;AAGlB5G,EAAAA,kBAAkB,EAAE,KAHF;AAIlB5D,EAAAA,UAAU,EAAE,KAJM;AAKlBC,EAAAA,SAAS,EAAE,KALO;AAMlB6F,EAAAA,iBAAiB,EAAE5N,0BAA0B,CAACe,OAN5B;AAOlB8K,EAAAA,aAAa,EAAE,UAPG;AAQlBC,EAAAA,cAAc,EAAE,EARE;AASlB2F,EAAAA,mBAAmB,EAAE,GATH;AAUlBC,EAAAA,gBAAgB,EAAE,EAVA;AAWlB5H,EAAAA,gBAAgB,EAAE5J,eAAe,CAACa,OAXhB;AAYlBiL,EAAAA,iBAAiB,EAAE7K,UAZD;AAalBmM,EAAAA,QAAQ,EAAE,SAASA,QAAT,GAAoB,CAAE,CAbd;AAclBgD,EAAAA,yBAAyB,EAAE,SAASA,yBAAT,GAAqC,CAAE,CAdhD;AAelBxN,EAAAA,iBAAiB,EAAE,SAASA,iBAAT,GAA6B,CAAE,CAfhC;AAgBlBgL,EAAAA,mBAAmB,EAAE,CAhBH;AAiBlBC,EAAAA,qBAAqB,EAAEnO,8BAA8B,CAACmB,OAjBpC;AAkBlBiN,EAAAA,gBAAgB,EAAE,EAlBA;AAmBlB/B,EAAAA,IAAI,EAAE,MAnBY;AAoBlByD,EAAAA,0BAA0B,EAAE5R,qCApBV;AAqBlBgJ,EAAAA,iBAAiB,EAAE,MArBD;AAsBlBrB,EAAAA,cAAc,EAAE,CAAC,CAtBC;AAuBlBE,EAAAA,WAAW,EAAE,CAAC,CAvBI;AAwBlBuG,EAAAA,KAAK,EAAE,EAxBW;AAyBlBC,EAAAA,QAAQ,EAAE,CAzBQ;AA0BlB8B,EAAAA,iBAAiB,EAAE;AA1BD,CAApB;AA4BA7M,IAAI,CAACmR,SAAL,GAAiBC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwC,IAAxC,GAA+C;AAC9D,gBAAcnS,WAAW,CAACQ,OAAZ,CAAoB4R,MAApB,CAA2BC,UADqB;AAE9D,mBAAiBrS,WAAW,CAACQ,OAAZ,CAAoB8R,IAFyB;;AAK9D;;;;AAIAnH,EAAAA,kBAAkB,EAAEnL,WAAW,CAACQ,OAAZ,CAAoB8R,IAApB,CAAyBD,UATiB;;AAY9D;;;;AAIA9K,EAAAA,UAAU,EAAEvH,WAAW,CAACQ,OAAZ,CAAoB8R,IAApB,CAAyBD,UAhByB;;AAmB9D;;;;AAIA7K,EAAAA,SAAS,EAAExH,WAAW,CAACQ,OAAZ,CAAoB8R,IAApB,CAAyBD,UAvB0B;;AA0B9D;AACAjF,EAAAA,YAAY,EAAE,SAASA,YAAT,GAAwB;AACpC,WAAO,CAAC,OAAOtN,MAAM,CAACyS,4BAAd,KAA+C,UAA/C,GAA4DzS,MAAM,CAACyS,4BAAP,CAAoCF,UAApC,GAAiDvS,MAAM,CAACyS,4BAAP,CAAoCF,UAArF,GAAkGvS,MAAM,CAACyS,4BAArK,GAAoMvS,WAAW,CAACQ,OAAZ,CAAoBgS,KAApB,CAA0B1S,MAAM,CAACyS,4BAAjC,EAA+DF,UAApQ,EAAgRI,KAAhR,CAAsR,IAAtR,EAA4RtM,SAA5R,CAAP;AACD,GA7B6D;;AAgC9D;AACAkH,EAAAA,iBAAiB,EAAE,SAASA,iBAAT,GAA6B;AAC9C,WAAO,CAAC,OAAOvN,MAAM,CAAC4S,iCAAd,KAAoD,UAApD,GAAiE5S,MAAM,CAAC4S,iCAAP,CAAyCL,UAAzC,GAAsDvS,MAAM,CAAC4S,iCAAP,CAAyCL,UAA/F,GAA4GvS,MAAM,CAAC4S,iCAApL,GAAwN1S,WAAW,CAACQ,OAAZ,CAAoBgS,KAApB,CAA0B1S,MAAM,CAAC4S,iCAAjC,EAAoEL,UAA7R,EAAySI,KAAzS,CAA+S,IAA/S,EAAqTtM,SAArT,CAAP;AACD,GAnC6D;;AAsC9D;AACAiF,EAAAA,SAAS,EAAEpL,WAAW,CAACQ,OAAZ,CAAoB4R,MAvC+B;;AA0C9D;AACArO,EAAAA,WAAW,EAAE/D,WAAW,CAACQ,OAAZ,CAAoBmS,MAApB,CAA2BN,UA3CsB;;AA8C9D;AACAlO,EAAAA,WAAW,EAAE,SAASA,WAAT,GAAuB;AAClC,WAAO,CAAC,OAAOrE,MAAM,CAAC8S,wBAAd,KAA2C,UAA3C,GAAwD9S,MAAM,CAAC8S,wBAAP,CAAgCP,UAAhC,GAA6CvS,MAAM,CAAC8S,wBAAP,CAAgCP,UAA7E,GAA0FvS,MAAM,CAAC8S,wBAAzJ,GAAoL5S,WAAW,CAACQ,OAAZ,CAAoBgS,KAApB,CAA0B1S,MAAM,CAAC8S,wBAAjC,EAA2DP,UAAhP,EAA4PI,KAA5P,CAAkQ,IAAlQ,EAAwQtM,SAAxQ,CAAP;AACD,GAjD6D;;AAoD9D;AACAkF,EAAAA,cAAc,EAAErL,WAAW,CAACQ,OAAZ,CAAoBqS,MArD0B;;AAwD9D;AACAvH,EAAAA,aAAa,EAAEtL,WAAW,CAACQ,OAAZ,CAAoB4R,MAApB,CAA2BC,UAzDoB;;AA4D9D;AACA9G,EAAAA,cAAc,EAAEvL,WAAW,CAACQ,OAAZ,CAAoBqS,MAApB,CAA2BR,UA7DmB;;AAgE9D;;;;AAIA/E,EAAAA,wBAAwB,EAAEtN,WAAW,CAACQ,OAAZ,CAAoBqS,MApEgB;;AAuE9D;;;;AAIA3B,EAAAA,mBAAmB,EAAElR,WAAW,CAACQ,OAAZ,CAAoBmS,MAApB,CAA2BN,UA3Ec;;AA8E9D;;;;AAIAlB,EAAAA,gBAAgB,EAAEnR,WAAW,CAACQ,OAAZ,CAAoBmS,MAApB,CAA2BN,UAlFiB;;AAqF9D;AACA9I,EAAAA,gBAAgB,EAAEvJ,WAAW,CAACQ,OAAZ,CAAoBsS,IAApB,CAAyBT,UAtFmB;;AAyF9D;AACA5K,EAAAA,MAAM,EAAEzH,WAAW,CAACQ,OAAZ,CAAoBmS,MAApB,CAA2BN,UA1F2B;;AA6F9D;AACA7G,EAAAA,EAAE,EAAExL,WAAW,CAACQ,OAAZ,CAAoB4R,MA9FsC;;AAiG9D;;;;AAIAhQ,EAAAA,WAAW,EAAEpC,WAAW,CAACQ,OAAZ,CAAoB8R,IArG6B;;AAwG9D;;;;AAIA5E,EAAAA,iBAAiB,EAAE1N,WAAW,CAACQ,OAAZ,CAAoB8R,IAApB,CAAyBD,UA5GkB;;AA+G9D;AACA5G,EAAAA,iBAAiB,EAAE,SAASA,iBAAT,GAA6B;AAC9C,WAAO,CAAC,OAAO3L,MAAM,CAACiT,iCAAd,KAAoD,UAApD,GAAiEjT,MAAM,CAACiT,iCAAP,CAAyCV,UAAzC,GAAsDvS,MAAM,CAACiT,iCAAP,CAAyCV,UAA/F,GAA4GvS,MAAM,CAACiT,iCAApL,GAAwN/S,WAAW,CAACQ,OAAZ,CAAoBgS,KAApB,CAA0B1S,MAAM,CAACiT,iCAAjC,EAAoEV,UAA7R,EAAySI,KAAzS,CAA+S,IAA/S,EAAqTtM,SAArT,CAAP;AACD,GAlH6D;;AAqH9D;;;;AAIA4G,EAAAA,QAAQ,EAAE/M,WAAW,CAACQ,OAAZ,CAAoBsS,IAApB,CAAyBT,UAzH2B;;AA4H9D;;;;;AAKAtC,EAAAA,yBAAyB,EAAE/P,WAAW,CAACQ,OAAZ,CAAoBsS,IAApB,CAAyBT,UAjIU;;AAoI9D;AACA9P,EAAAA,iBAAiB,EAAEvC,WAAW,CAACQ,OAAZ,CAAoBsS,IAApB,CAAyBT,UArIkB;;AAwI9D;;;;AAIA9E,EAAAA,mBAAmB,EAAEvN,WAAW,CAACQ,OAAZ,CAAoBmS,MAApB,CAA2BN,UA5Ic;;AA+I9D;;;;AAIA7E,EAAAA,qBAAqB,EAAE,SAASA,qBAAT,GAAiC;AACtD,WAAO,CAAC,OAAO1N,MAAM,CAACkT,qCAAd,KAAwD,UAAxD,GAAqElT,MAAM,CAACkT,qCAAP,CAA6CX,UAA7C,GAA0DvS,MAAM,CAACkT,qCAAP,CAA6CX,UAAvG,GAAoHvS,MAAM,CAACkT,qCAAhM,GAAwOhT,WAAW,CAACQ,OAAZ,CAAoBgS,KAApB,CAA0B1S,MAAM,CAACkT,qCAAjC,EAAwEX,UAAjT,EAA6TI,KAA7T,CAAmU,IAAnU,EAAyUtM,SAAzU,CAAP;AACD,GArJ6D;;AAwJ9D;;;;AAIAsH,EAAAA,gBAAgB,EAAEzN,WAAW,CAACQ,OAAZ,CAAoBmS,MAApB,CAA2BN,UA5JiB;;AA+J9D;AACA3G,EAAAA,IAAI,EAAE1L,WAAW,CAACQ,OAAZ,CAAoB4R,MAApB,CAA2BC,UAhK6B;;AAmK9D;;;;AAIA7N,EAAAA,SAAS,EAAE,SAASA,SAAT,GAAqB;AAC9B,WAAO,CAAC,OAAO1E,MAAM,CAAC8S,wBAAd,KAA2C,UAA3C,GAAwD9S,MAAM,CAAC8S,wBAAP,CAAgCP,UAAhC,GAA6CvS,MAAM,CAAC8S,wBAAP,CAAgCP,UAA7E,GAA0FvS,MAAM,CAAC8S,wBAAzJ,GAAoL5S,WAAW,CAACQ,OAAZ,CAAoBgS,KAApB,CAA0B1S,MAAM,CAAC8S,wBAAjC,EAA2DP,UAAhP,EAA4PI,KAA5P,CAAkQ,IAAlQ,EAAwQtM,SAAxQ,CAAP;AACD,GAzK6D;;AA4K9D;AACA5B,EAAAA,QAAQ,EAAEvE,WAAW,CAACQ,OAAZ,CAAoBmS,MAApB,CAA2BN,UA7KyB;;AAgL9D;AACAlD,EAAAA,0BAA0B,EAAEnP,WAAW,CAACQ,OAAZ,CAAoBmS,MAApB,CAA2BN,UAjLO;;AAoL9D;AACA3M,EAAAA,UAAU,EAAE1F,WAAW,CAACQ,OAAZ,CAAoBmS,MArL8B;;AAwL9D;;;;;AAKApM,EAAAA,iBAAiB,EAAE,SAASA,iBAAT,GAA6B;AAC9C,WAAO,CAAC,OAAOzG,MAAM,CAACmT,yBAAd,KAA4C,UAA5C,GAAyDnT,MAAM,CAACmT,yBAAP,CAAiCZ,UAAjC,GAA8CvS,MAAM,CAACmT,yBAAP,CAAiCZ,UAA/E,GAA4FvS,MAAM,CAACmT,yBAA5J,GAAwLjT,WAAW,CAACQ,OAAZ,CAAoBgS,KAApB,CAA0B1S,MAAM,CAACmT,yBAAjC,EAA4DZ,UAArP,EAAiQI,KAAjQ,CAAuQ,IAAvQ,EAA6QtM,SAA7Q,CAAP;AACD,GA/L6D;;AAkM9D;AACAjB,EAAAA,cAAc,EAAElF,WAAW,CAACQ,OAAZ,CAAoBmS,MAApB,CAA2BN,UAnMmB;;AAsM9D;AACA1M,EAAAA,SAAS,EAAE3F,WAAW,CAACQ,OAAZ,CAAoBmS,MAvM+B;;AA0M9D;AACAvN,EAAAA,WAAW,EAAEpF,WAAW,CAACQ,OAAZ,CAAoBmS,MAApB,CAA2BN,UA3MsB;;AA8M9D;AACA1G,EAAAA,KAAK,EAAE3L,WAAW,CAACQ,OAAZ,CAAoBqS,MAApB,CAA2BR,UA/M4B;;AAkN9D;AACAzG,EAAAA,QAAQ,EAAE5L,WAAW,CAACQ,OAAZ,CAAoBmS,MAnNgC;;AAsN9D;AACAjL,EAAAA,KAAK,EAAE1H,WAAW,CAACQ,OAAZ,CAAoBmS,MAApB,CAA2BN;AAvN4B,CAAhE;AA2NA,CAAC,GAAGzS,sBAAsB,CAACsT,QAA3B,EAAqCrS,IAArC;AACAxD,OAAO,CAACmD,OAAR,GAAkBK,IAAlB","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = undefined;\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _extends2 = require('babel-runtime/helpers/extends');\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _react = require('react');\n\nvar React = _interopRequireWildcard(_react);\n\nvar _clsx = require('clsx');\n\nvar _clsx2 = _interopRequireDefault(_clsx);\n\nvar _calculateSizeAndPositionDataAndUpdateScrollOffset = require('./utils/calculateSizeAndPositionDataAndUpdateScrollOffset');\n\nvar _calculateSizeAndPositionDataAndUpdateScrollOffset2 = _interopRequireDefault(_calculateSizeAndPositionDataAndUpdateScrollOffset);\n\nvar _ScalingCellSizeAndPositionManager = require('./utils/ScalingCellSizeAndPositionManager');\n\nvar _ScalingCellSizeAndPositionManager2 = _interopRequireDefault(_ScalingCellSizeAndPositionManager);\n\nvar _createCallbackMemoizer = require('../utils/createCallbackMemoizer');\n\nvar _createCallbackMemoizer2 = _interopRequireDefault(_createCallbackMemoizer);\n\nvar _defaultOverscanIndicesGetter = require('./defaultOverscanIndicesGetter');\n\nvar _defaultOverscanIndicesGetter2 = _interopRequireDefault(_defaultOverscanIndicesGetter);\n\nvar _updateScrollIndexHelper = require('./utils/updateScrollIndexHelper');\n\nvar _updateScrollIndexHelper2 = _interopRequireDefault(_updateScrollIndexHelper);\n\nvar _defaultCellRangeRenderer = require('./defaultCellRangeRenderer');\n\nvar _defaultCellRangeRenderer2 = _interopRequireDefault(_defaultCellRangeRenderer);\n\nvar _scrollbarSize = require('dom-helpers/scrollbarSize');\n\nvar _scrollbarSize2 = _interopRequireDefault(_scrollbarSize);\n\nvar _reactLifecyclesCompat = require('react-lifecycles-compat');\n\nvar _requestAnimationTimeout = require('../utils/requestAnimationTimeout');\n\nvar _types = require('./types');\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.\n * This improves performance and makes scrolling smoother.\n */\nvar DEFAULT_SCROLLING_RESET_TIME_INTERVAL = exports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = 150;\n\n/**\n * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.\n * This prevents Grid from interrupting mouse-wheel animations (see issue #2).\n */\n\n\nvar SCROLL_POSITION_CHANGE_REASONS = {\n  OBSERVED: 'observed',\n  REQUESTED: 'requested'\n};\n\nvar renderNull = function renderNull() {\n  return null;\n};\n\n/**\n * Renders tabular data with virtualization along the vertical and horizontal axes.\n * Row heights and column widths must be known ahead of time and specified as properties.\n */\nvar Grid = function (_React$PureComponent) {\n  (0, _inherits3.default)(Grid, _React$PureComponent);\n\n  // Invokes onSectionRendered callback only when start/stop row or column indices change\n  function Grid(props) {\n    (0, _classCallCheck3.default)(this, Grid);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (Grid.__proto__ || (0, _getPrototypeOf2.default)(Grid)).call(this, props));\n\n    _this._onGridRenderedMemoizer = (0, _createCallbackMemoizer2.default)();\n    _this._onScrollMemoizer = (0, _createCallbackMemoizer2.default)(false);\n    _this._deferredInvalidateColumnIndex = null;\n    _this._deferredInvalidateRowIndex = null;\n    _this._recomputeScrollLeftFlag = false;\n    _this._recomputeScrollTopFlag = false;\n    _this._horizontalScrollBarSize = 0;\n    _this._verticalScrollBarSize = 0;\n    _this._scrollbarPresenceChanged = false;\n    _this._renderedColumnStartIndex = 0;\n    _this._renderedColumnStopIndex = 0;\n    _this._renderedRowStartIndex = 0;\n    _this._renderedRowStopIndex = 0;\n    _this._styleCache = {};\n    _this._cellCache = {};\n\n    _this._debounceScrollEndedCallback = function () {\n      _this._disablePointerEventsTimeoutId = null;\n      // isScrolling is used to determine if we reset styleCache\n      _this.setState({\n        isScrolling: false,\n        needToResetStyleCache: false\n      });\n    };\n\n    _this._invokeOnGridRenderedHelper = function () {\n      var onSectionRendered = _this.props.onSectionRendered;\n\n\n      _this._onGridRenderedMemoizer({\n        callback: onSectionRendered,\n        indices: {\n          columnOverscanStartIndex: _this._columnStartIndex,\n          columnOverscanStopIndex: _this._columnStopIndex,\n          columnStartIndex: _this._renderedColumnStartIndex,\n          columnStopIndex: _this._renderedColumnStopIndex,\n          rowOverscanStartIndex: _this._rowStartIndex,\n          rowOverscanStopIndex: _this._rowStopIndex,\n          rowStartIndex: _this._renderedRowStartIndex,\n          rowStopIndex: _this._renderedRowStopIndex\n        }\n      });\n    };\n\n    _this._setScrollingContainerRef = function (ref) {\n      _this._scrollingContainer = ref;\n    };\n\n    _this._onScroll = function (event) {\n      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.\n      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.\n      // See issue #404 for more information.\n      if (event.target === _this._scrollingContainer) {\n        _this.handleScrollEvent(event.target);\n      }\n    };\n\n    var columnSizeAndPositionManager = new _ScalingCellSizeAndPositionManager2.default({\n      cellCount: props.columnCount,\n      cellSizeGetter: function cellSizeGetter(params) {\n        return Grid._wrapSizeGetter(props.columnWidth)(params);\n      },\n      estimatedCellSize: Grid._getEstimatedColumnSize(props)\n    });\n    var rowSizeAndPositionManager = new _ScalingCellSizeAndPositionManager2.default({\n      cellCount: props.rowCount,\n      cellSizeGetter: function cellSizeGetter(params) {\n        return Grid._wrapSizeGetter(props.rowHeight)(params);\n      },\n      estimatedCellSize: Grid._getEstimatedRowSize(props)\n    });\n\n    _this.state = {\n      instanceProps: {\n        columnSizeAndPositionManager: columnSizeAndPositionManager,\n        rowSizeAndPositionManager: rowSizeAndPositionManager,\n\n        prevColumnWidth: props.columnWidth,\n        prevRowHeight: props.rowHeight,\n        prevColumnCount: props.columnCount,\n        prevRowCount: props.rowCount,\n        prevIsScrolling: props.isScrolling === true,\n        prevScrollToColumn: props.scrollToColumn,\n        prevScrollToRow: props.scrollToRow,\n\n        scrollbarSize: 0,\n        scrollbarSizeMeasured: false\n      },\n      isScrolling: false,\n      scrollDirectionHorizontal: _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD,\n      scrollDirectionVertical: _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD,\n      scrollLeft: 0,\n      scrollTop: 0,\n      scrollPositionChangeReason: null,\n\n      needToResetStyleCache: false\n    };\n\n    if (props.scrollToRow > 0) {\n      _this._initialScrollTop = _this._getCalculatedScrollTop(props, _this.state);\n    }\n    if (props.scrollToColumn > 0) {\n      _this._initialScrollLeft = _this._getCalculatedScrollLeft(props, _this.state);\n    }\n    return _this;\n  }\n\n  /**\n   * Gets offsets for a given cell and alignment.\n   */\n\n\n  (0, _createClass3.default)(Grid, [{\n    key: 'getOffsetForCell',\n    value: function getOffsetForCell() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$alignment = _ref.alignment,\n          alignment = _ref$alignment === undefined ? this.props.scrollToAlignment : _ref$alignment,\n          _ref$columnIndex = _ref.columnIndex,\n          columnIndex = _ref$columnIndex === undefined ? this.props.scrollToColumn : _ref$columnIndex,\n          _ref$rowIndex = _ref.rowIndex,\n          rowIndex = _ref$rowIndex === undefined ? this.props.scrollToRow : _ref$rowIndex;\n\n      var offsetProps = (0, _extends3.default)({}, this.props, {\n        scrollToAlignment: alignment,\n        scrollToColumn: columnIndex,\n        scrollToRow: rowIndex\n      });\n\n      return {\n        scrollLeft: this._getCalculatedScrollLeft(offsetProps),\n        scrollTop: this._getCalculatedScrollTop(offsetProps)\n      };\n    }\n\n    /**\n     * Gets estimated total rows' height.\n     */\n\n  }, {\n    key: 'getTotalRowsHeight',\n    value: function getTotalRowsHeight() {\n      return this.state.instanceProps.rowSizeAndPositionManager.getTotalSize();\n    }\n\n    /**\n     * Gets estimated total columns' width.\n     */\n\n  }, {\n    key: 'getTotalColumnsWidth',\n    value: function getTotalColumnsWidth() {\n      return this.state.instanceProps.columnSizeAndPositionManager.getTotalSize();\n    }\n\n    /**\n     * This method handles a scroll event originating from an external scroll control.\n     * It's an advanced method and should probably not be used unless you're implementing a custom scroll-bar solution.\n     */\n\n  }, {\n    key: 'handleScrollEvent',\n    value: function handleScrollEvent(_ref2) {\n      var _ref2$scrollLeft = _ref2.scrollLeft,\n          scrollLeftParam = _ref2$scrollLeft === undefined ? 0 : _ref2$scrollLeft,\n          _ref2$scrollTop = _ref2.scrollTop,\n          scrollTopParam = _ref2$scrollTop === undefined ? 0 : _ref2$scrollTop;\n\n      // On iOS, we can arrive at negative offsets by swiping past the start.\n      // To prevent flicker here, we make playing in the negative offset zone cause nothing to happen.\n      if (scrollTopParam < 0) {\n        return;\n      }\n\n      // Prevent pointer events from interrupting a smooth scroll\n      this._debounceScrollEnded();\n\n      var _props = this.props,\n          autoHeight = _props.autoHeight,\n          autoWidth = _props.autoWidth,\n          height = _props.height,\n          width = _props.width;\n      var instanceProps = this.state.instanceProps;\n\n      // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,\n      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.\n      // This causes a series of rapid renders that is slow for long lists.\n      // We can avoid that by doing some simple bounds checking to ensure that scroll offsets never exceed their bounds.\n\n      var scrollbarSize = instanceProps.scrollbarSize;\n      var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n      var scrollLeft = Math.min(Math.max(0, totalColumnsWidth - width + scrollbarSize), scrollLeftParam);\n      var scrollTop = Math.min(Math.max(0, totalRowsHeight - height + scrollbarSize), scrollTopParam);\n\n      // Certain devices (like Apple touchpad) rapid-fire duplicate events.\n      // Don't force a re-render if this is the case.\n      // The mouse may move faster then the animation frame does.\n      // Use requestAnimationFrame to avoid over-updating.\n      if (this.state.scrollLeft !== scrollLeft || this.state.scrollTop !== scrollTop) {\n        // Track scrolling direction so we can more efficiently overscan rows to reduce empty space around the edges while scrolling.\n        // Don't change direction for an axis unless scroll offset has changed.\n        var _scrollDirectionHorizontal = scrollLeft !== this.state.scrollLeft ? scrollLeft > this.state.scrollLeft ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionHorizontal;\n        var _scrollDirectionVertical = scrollTop !== this.state.scrollTop ? scrollTop > this.state.scrollTop ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionVertical;\n\n        var newState = {\n          isScrolling: true,\n          scrollDirectionHorizontal: _scrollDirectionHorizontal,\n          scrollDirectionVertical: _scrollDirectionVertical,\n          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.OBSERVED\n        };\n\n        if (!autoHeight) {\n          newState.scrollTop = scrollTop;\n        }\n\n        if (!autoWidth) {\n          newState.scrollLeft = scrollLeft;\n        }\n\n        newState.needToResetStyleCache = false;\n        this.setState(newState);\n      }\n\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop,\n        totalColumnsWidth: totalColumnsWidth,\n        totalRowsHeight: totalRowsHeight\n      });\n    }\n\n    /**\n     * Invalidate Grid size and recompute visible cells.\n     * This is a deferred wrapper for recomputeGridSize().\n     * It sets a flag to be evaluated on cDM/cDU to avoid unnecessary renders.\n     * This method is intended for advanced use-cases like CellMeasurer.\n     */\n    // @TODO (bvaughn) Add automated test coverage for this.\n\n  }, {\n    key: 'invalidateCellSizeAfterRender',\n    value: function invalidateCellSizeAfterRender(_ref3) {\n      var columnIndex = _ref3.columnIndex,\n          rowIndex = _ref3.rowIndex;\n\n      this._deferredInvalidateColumnIndex = typeof this._deferredInvalidateColumnIndex === 'number' ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex;\n      this._deferredInvalidateRowIndex = typeof this._deferredInvalidateRowIndex === 'number' ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;\n    }\n\n    /**\n     * Pre-measure all columns and rows in a Grid.\n     * Typically cells are only measured as needed and estimated sizes are used for cells that have not yet been measured.\n     * This method ensures that the next call to getTotalSize() returns an exact size (as opposed to just an estimated one).\n     */\n\n  }, {\n    key: 'measureAllCells',\n    value: function measureAllCells() {\n      var _props2 = this.props,\n          columnCount = _props2.columnCount,\n          rowCount = _props2.rowCount;\n      var instanceProps = this.state.instanceProps;\n\n      instanceProps.columnSizeAndPositionManager.getSizeAndPositionOfCell(columnCount - 1);\n      instanceProps.rowSizeAndPositionManager.getSizeAndPositionOfCell(rowCount - 1);\n    }\n\n    /**\n     * Forced recompute of row heights and column widths.\n     * This function should be called if dynamic column or row sizes have changed but nothing else has.\n     * Since Grid only receives :columnCount and :rowCount it has no way of detecting when the underlying data changes.\n     */\n\n  }, {\n    key: 'recomputeGridSize',\n    value: function recomputeGridSize() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref4$columnIndex = _ref4.columnIndex,\n          columnIndex = _ref4$columnIndex === undefined ? 0 : _ref4$columnIndex,\n          _ref4$rowIndex = _ref4.rowIndex,\n          rowIndex = _ref4$rowIndex === undefined ? 0 : _ref4$rowIndex;\n\n      var _props3 = this.props,\n          scrollToColumn = _props3.scrollToColumn,\n          scrollToRow = _props3.scrollToRow;\n      var instanceProps = this.state.instanceProps;\n\n\n      instanceProps.columnSizeAndPositionManager.resetCell(columnIndex);\n      instanceProps.rowSizeAndPositionManager.resetCell(rowIndex);\n\n      // Cell sizes may be determined by a function property.\n      // In this case the cDU handler can't know if they changed.\n      // Store this flag to let the next cDU pass know it needs to recompute the scroll offset.\n      this._recomputeScrollLeftFlag = scrollToColumn >= 0 && (this.state.scrollDirectionHorizontal === _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD ? columnIndex <= scrollToColumn : columnIndex >= scrollToColumn);\n      this._recomputeScrollTopFlag = scrollToRow >= 0 && (this.state.scrollDirectionVertical === _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD ? rowIndex <= scrollToRow : rowIndex >= scrollToRow);\n\n      // Clear cell cache in case we are scrolling;\n      // Invalid row heights likely mean invalid cached content as well.\n      this._styleCache = {};\n      this._cellCache = {};\n\n      this.forceUpdate();\n    }\n\n    /**\n     * Ensure column and row are visible.\n     */\n\n  }, {\n    key: 'scrollToCell',\n    value: function scrollToCell(_ref5) {\n      var columnIndex = _ref5.columnIndex,\n          rowIndex = _ref5.rowIndex;\n      var columnCount = this.props.columnCount;\n\n\n      var props = this.props;\n\n      // Don't adjust scroll offset for single-column grids (eg List, Table).\n      // This can cause a funky scroll offset because of the vertical scrollbar width.\n      if (columnCount > 1 && columnIndex !== undefined) {\n        this._updateScrollLeftForScrollToColumn((0, _extends3.default)({}, props, {\n          scrollToColumn: columnIndex\n        }));\n      }\n\n      if (rowIndex !== undefined) {\n        this._updateScrollTopForScrollToRow((0, _extends3.default)({}, props, {\n          scrollToRow: rowIndex\n        }));\n      }\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var _props4 = this.props,\n          getScrollbarSize = _props4.getScrollbarSize,\n          height = _props4.height,\n          scrollLeft = _props4.scrollLeft,\n          scrollToColumn = _props4.scrollToColumn,\n          scrollTop = _props4.scrollTop,\n          scrollToRow = _props4.scrollToRow,\n          width = _props4.width;\n      var instanceProps = this.state.instanceProps;\n\n      // Reset initial offsets to be ignored in browser\n\n      this._initialScrollTop = 0;\n      this._initialScrollLeft = 0;\n\n      // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\n      // We must do this at the start of the method as we may calculate and update scroll position below.\n      this._handleInvalidatedGridSize();\n\n      // If this component was first rendered server-side, scrollbar size will be undefined.\n      // In that event we need to remeasure.\n      if (!instanceProps.scrollbarSizeMeasured) {\n        this.setState(function (prevState) {\n          var stateUpdate = (0, _extends3.default)({}, prevState, { needToResetStyleCache: false });\n          stateUpdate.instanceProps.scrollbarSize = getScrollbarSize();\n          stateUpdate.instanceProps.scrollbarSizeMeasured = true;\n          return stateUpdate;\n        });\n      }\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0 || typeof scrollTop === 'number' && scrollTop >= 0) {\n        var stateUpdate = Grid._getScrollToPositionStateUpdate({\n          prevState: this.state,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        });\n        if (stateUpdate) {\n          stateUpdate.needToResetStyleCache = false;\n          this.setState(stateUpdate);\n        }\n      }\n\n      // refs don't work in `react-test-renderer`\n      if (this._scrollingContainer) {\n        // setting the ref's scrollLeft and scrollTop.\n        // Somehow in MultiGrid the main grid doesn't trigger a update on mount.\n        if (this._scrollingContainer.scrollLeft !== this.state.scrollLeft) {\n          this._scrollingContainer.scrollLeft = this.state.scrollLeft;\n        }\n        if (this._scrollingContainer.scrollTop !== this.state.scrollTop) {\n          this._scrollingContainer.scrollTop = this.state.scrollTop;\n        }\n      }\n\n      // Don't update scroll offset if the size is 0; we don't render any cells in this case.\n      // Setting a state may cause us to later thing we've updated the offce when we haven't.\n      var sizeIsBiggerThanZero = height > 0 && width > 0;\n      if (scrollToColumn >= 0 && sizeIsBiggerThanZero) {\n        this._updateScrollLeftForScrollToColumn();\n      }\n      if (scrollToRow >= 0 && sizeIsBiggerThanZero) {\n        this._updateScrollTopForScrollToRow();\n      }\n\n      // Update onRowsRendered callback\n      this._invokeOnGridRenderedHelper();\n\n      // Initialize onScroll callback\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft || 0,\n        scrollTop: scrollTop || 0,\n        totalColumnsWidth: instanceProps.columnSizeAndPositionManager.getTotalSize(),\n        totalRowsHeight: instanceProps.rowSizeAndPositionManager.getTotalSize()\n      });\n\n      this._maybeCallOnScrollbarPresenceChange();\n    }\n\n    /**\n     * @private\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) New scroll-to-cell props have been set\n     */\n\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this2 = this;\n\n      var _props5 = this.props,\n          autoHeight = _props5.autoHeight,\n          autoWidth = _props5.autoWidth,\n          columnCount = _props5.columnCount,\n          height = _props5.height,\n          rowCount = _props5.rowCount,\n          scrollToAlignment = _props5.scrollToAlignment,\n          scrollToColumn = _props5.scrollToColumn,\n          scrollToRow = _props5.scrollToRow,\n          width = _props5.width;\n      var _state = this.state,\n          scrollLeft = _state.scrollLeft,\n          scrollPositionChangeReason = _state.scrollPositionChangeReason,\n          scrollTop = _state.scrollTop,\n          instanceProps = _state.instanceProps;\n      // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\n      // We must do this at the start of the method as we may calculate and update scroll position below.\n\n      this._handleInvalidatedGridSize();\n\n      // Handle edge case where column or row count has only just increased over 0.\n      // In this case we may have to restore a previously-specified scroll offset.\n      // For more info see bvaughn/react-virtualized/issues/218\n      var columnOrRowCountJustIncreasedFromZero = columnCount > 0 && prevProps.columnCount === 0 || rowCount > 0 && prevProps.rowCount === 0;\n\n      // Make sure requested changes to :scrollLeft or :scrollTop get applied.\n      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,\n      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).\n      // So we only set these when we require an adjustment of the scroll position.\n      // See issue #2 for more information.\n      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {\n        // @TRICKY :autoHeight and :autoWidth properties instructs Grid to leave :scrollTop and :scrollLeft management to an external HOC (eg WindowScroller).\n        // In this case we should avoid checking scrollingContainer.scrollTop and scrollingContainer.scrollLeft since it forces layout/flow.\n        if (!autoWidth && scrollLeft >= 0 && (scrollLeft !== this._scrollingContainer.scrollLeft || columnOrRowCountJustIncreasedFromZero)) {\n          this._scrollingContainer.scrollLeft = scrollLeft;\n        }\n        if (!autoHeight && scrollTop >= 0 && (scrollTop !== this._scrollingContainer.scrollTop || columnOrRowCountJustIncreasedFromZero)) {\n          this._scrollingContainer.scrollTop = scrollTop;\n        }\n      }\n\n      // Special case where the previous size was 0:\n      // In this case we don't show any windowed cells at all.\n      // So we should always recalculate offset afterwards.\n      var sizeJustIncreasedFromZero = (prevProps.width === 0 || prevProps.height === 0) && height > 0 && width > 0;\n\n      // Update scroll offsets if the current :scrollToColumn or :scrollToRow values requires it\n      // @TODO Do we also need this check or can the one in componentWillUpdate() suffice?\n      if (this._recomputeScrollLeftFlag) {\n        this._recomputeScrollLeftFlag = false;\n        this._updateScrollLeftForScrollToColumn(this.props);\n      } else {\n        (0, _updateScrollIndexHelper2.default)({\n          cellSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\n          previousCellsCount: prevProps.columnCount,\n          previousCellSize: prevProps.columnWidth,\n          previousScrollToAlignment: prevProps.scrollToAlignment,\n          previousScrollToIndex: prevProps.scrollToColumn,\n          previousSize: prevProps.width,\n          scrollOffset: scrollLeft,\n          scrollToAlignment: scrollToAlignment,\n          scrollToIndex: scrollToColumn,\n          size: width,\n          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,\n          updateScrollIndexCallback: function updateScrollIndexCallback() {\n            return _this2._updateScrollLeftForScrollToColumn(_this2.props);\n          }\n        });\n      }\n\n      if (this._recomputeScrollTopFlag) {\n        this._recomputeScrollTopFlag = false;\n        this._updateScrollTopForScrollToRow(this.props);\n      } else {\n        (0, _updateScrollIndexHelper2.default)({\n          cellSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\n          previousCellsCount: prevProps.rowCount,\n          previousCellSize: prevProps.rowHeight,\n          previousScrollToAlignment: prevProps.scrollToAlignment,\n          previousScrollToIndex: prevProps.scrollToRow,\n          previousSize: prevProps.height,\n          scrollOffset: scrollTop,\n          scrollToAlignment: scrollToAlignment,\n          scrollToIndex: scrollToRow,\n          size: height,\n          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,\n          updateScrollIndexCallback: function updateScrollIndexCallback() {\n            return _this2._updateScrollTopForScrollToRow(_this2.props);\n          }\n        });\n      }\n\n      // Update onRowsRendered callback if start/stop indices have changed\n      this._invokeOnGridRenderedHelper();\n\n      // Changes to :scrollLeft or :scrollTop should also notify :onScroll listeners\n      if (scrollLeft !== prevState.scrollLeft || scrollTop !== prevState.scrollTop) {\n        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n\n        this._invokeOnScrollMemoizer({\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          totalColumnsWidth: totalColumnsWidth,\n          totalRowsHeight: totalRowsHeight\n        });\n      }\n\n      this._maybeCallOnScrollbarPresenceChange();\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      if (this._disablePointerEventsTimeoutId) {\n        (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId);\n      }\n    }\n\n    /**\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) Empty content (0 rows or columns)\n     * 2) New scroll props overriding the current state\n     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid\n     */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props6 = this.props,\n          autoContainerWidth = _props6.autoContainerWidth,\n          autoHeight = _props6.autoHeight,\n          autoWidth = _props6.autoWidth,\n          className = _props6.className,\n          containerProps = _props6.containerProps,\n          containerRole = _props6.containerRole,\n          containerStyle = _props6.containerStyle,\n          height = _props6.height,\n          id = _props6.id,\n          noContentRenderer = _props6.noContentRenderer,\n          role = _props6.role,\n          style = _props6.style,\n          tabIndex = _props6.tabIndex,\n          width = _props6.width;\n      var _state2 = this.state,\n          instanceProps = _state2.instanceProps,\n          needToResetStyleCache = _state2.needToResetStyleCache;\n\n\n      var isScrolling = this._isScrolling();\n\n      var gridStyle = {\n        boxSizing: 'border-box',\n        direction: 'ltr',\n        height: autoHeight ? 'auto' : height,\n        position: 'relative',\n        width: autoWidth ? 'auto' : width,\n        WebkitOverflowScrolling: 'touch',\n        willChange: 'transform'\n      };\n\n      if (needToResetStyleCache) {\n        this._styleCache = {};\n      }\n\n      // calculate _styleCache here\n      // if state.isScrolling (not from _isScrolling) then reset\n      if (!this.state.isScrolling) {\n        this._resetStyleCache();\n      }\n\n      // calculate children to render here\n      this._calculateChildrenToRender(this.props, this.state);\n\n      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n      var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n\n      // Force browser to hide scrollbars when we know they aren't necessary.\n      // Otherwise once scrollbars appear they may not disappear again.\n      // For more info see issue #116\n      var verticalScrollBarSize = totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\n      var horizontalScrollBarSize = totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\n\n      if (horizontalScrollBarSize !== this._horizontalScrollBarSize || verticalScrollBarSize !== this._verticalScrollBarSize) {\n        this._horizontalScrollBarSize = horizontalScrollBarSize;\n        this._verticalScrollBarSize = verticalScrollBarSize;\n        this._scrollbarPresenceChanged = true;\n      }\n\n      // Also explicitly init styles to 'auto' if scrollbars are required.\n      // This works around an obscure edge case where external CSS styles have not yet been loaded,\n      // But an initial scroll index of offset is set as an external prop.\n      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.\n      // This was originally reported via clauderic/react-infinite-calendar/issues/23\n      gridStyle.overflowX = totalColumnsWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';\n      gridStyle.overflowY = totalRowsHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';\n\n      var childrenToDisplay = this._childrenToDisplay;\n\n      var showNoContentRenderer = childrenToDisplay.length === 0 && height > 0 && width > 0;\n\n      return React.createElement(\n        'div',\n        (0, _extends3.default)({\n          ref: this._setScrollingContainerRef\n        }, containerProps, {\n          'aria-label': this.props['aria-label'],\n          'aria-readonly': this.props['aria-readonly'],\n          className: (0, _clsx2.default)('ReactVirtualized__Grid', className),\n          id: id,\n          onScroll: this._onScroll,\n          role: role,\n          style: (0, _extends3.default)({}, gridStyle, style),\n          tabIndex: tabIndex }),\n        childrenToDisplay.length > 0 && React.createElement(\n          'div',\n          {\n            className: 'ReactVirtualized__Grid__innerScrollContainer',\n            role: containerRole,\n            style: (0, _extends3.default)({\n              width: autoContainerWidth ? 'auto' : totalColumnsWidth,\n              height: totalRowsHeight,\n              maxWidth: totalColumnsWidth,\n              maxHeight: totalRowsHeight,\n              overflow: 'hidden',\n              pointerEvents: isScrolling ? 'none' : '',\n              position: 'relative'\n            }, containerStyle) },\n          childrenToDisplay\n        ),\n        showNoContentRenderer && noContentRenderer()\n      );\n    }\n\n    /* ---------------------------- Helper methods ---------------------------- */\n\n  }, {\n    key: '_calculateChildrenToRender',\n    value: function _calculateChildrenToRender() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      var cellRenderer = props.cellRenderer,\n          cellRangeRenderer = props.cellRangeRenderer,\n          columnCount = props.columnCount,\n          deferredMeasurementCache = props.deferredMeasurementCache,\n          height = props.height,\n          overscanColumnCount = props.overscanColumnCount,\n          overscanIndicesGetter = props.overscanIndicesGetter,\n          overscanRowCount = props.overscanRowCount,\n          rowCount = props.rowCount,\n          width = props.width,\n          isScrollingOptOut = props.isScrollingOptOut;\n      var scrollDirectionHorizontal = state.scrollDirectionHorizontal,\n          scrollDirectionVertical = state.scrollDirectionVertical,\n          instanceProps = state.instanceProps;\n\n\n      var scrollTop = this._initialScrollTop > 0 ? this._initialScrollTop : state.scrollTop;\n      var scrollLeft = this._initialScrollLeft > 0 ? this._initialScrollLeft : state.scrollLeft;\n\n      var isScrolling = this._isScrolling(props, state);\n\n      this._childrenToDisplay = [];\n\n      // Render only enough columns and rows to cover the visible area of the grid.\n      if (height > 0 && width > 0) {\n        var visibleColumnIndices = instanceProps.columnSizeAndPositionManager.getVisibleCellRange({\n          containerSize: width,\n          offset: scrollLeft\n        });\n        var visibleRowIndices = instanceProps.rowSizeAndPositionManager.getVisibleCellRange({\n          containerSize: height,\n          offset: scrollTop\n        });\n\n        var horizontalOffsetAdjustment = instanceProps.columnSizeAndPositionManager.getOffsetAdjustment({\n          containerSize: width,\n          offset: scrollLeft\n        });\n        var verticalOffsetAdjustment = instanceProps.rowSizeAndPositionManager.getOffsetAdjustment({\n          containerSize: height,\n          offset: scrollTop\n        });\n\n        // Store for _invokeOnGridRenderedHelper()\n        this._renderedColumnStartIndex = visibleColumnIndices.start;\n        this._renderedColumnStopIndex = visibleColumnIndices.stop;\n        this._renderedRowStartIndex = visibleRowIndices.start;\n        this._renderedRowStopIndex = visibleRowIndices.stop;\n\n        var overscanColumnIndices = overscanIndicesGetter({\n          direction: 'horizontal',\n          cellCount: columnCount,\n          overscanCellsCount: overscanColumnCount,\n          scrollDirection: scrollDirectionHorizontal,\n          startIndex: typeof visibleColumnIndices.start === 'number' ? visibleColumnIndices.start : 0,\n          stopIndex: typeof visibleColumnIndices.stop === 'number' ? visibleColumnIndices.stop : -1\n        });\n\n        var overscanRowIndices = overscanIndicesGetter({\n          direction: 'vertical',\n          cellCount: rowCount,\n          overscanCellsCount: overscanRowCount,\n          scrollDirection: scrollDirectionVertical,\n          startIndex: typeof visibleRowIndices.start === 'number' ? visibleRowIndices.start : 0,\n          stopIndex: typeof visibleRowIndices.stop === 'number' ? visibleRowIndices.stop : -1\n        });\n\n        // Store for _invokeOnGridRenderedHelper()\n        var columnStartIndex = overscanColumnIndices.overscanStartIndex;\n        var columnStopIndex = overscanColumnIndices.overscanStopIndex;\n        var rowStartIndex = overscanRowIndices.overscanStartIndex;\n        var rowStopIndex = overscanRowIndices.overscanStopIndex;\n\n        // Advanced use-cases (eg CellMeasurer) require batched measurements to determine accurate sizes.\n        if (deferredMeasurementCache) {\n          // If rows have a dynamic height, scan the rows we are about to render.\n          // If any have not yet been measured, then we need to render all columns initially,\n          // Because the height of the row is equal to the tallest cell within that row,\n          // (And so we can't know the height without measuring all column-cells first).\n          if (!deferredMeasurementCache.hasFixedHeight()) {\n            for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {\n              if (!deferredMeasurementCache.has(rowIndex, 0)) {\n                columnStartIndex = 0;\n                columnStopIndex = columnCount - 1;\n                break;\n              }\n            }\n          }\n\n          // If columns have a dynamic width, scan the columns we are about to render.\n          // If any have not yet been measured, then we need to render all rows initially,\n          // Because the width of the column is equal to the widest cell within that column,\n          // (And so we can't know the width without measuring all row-cells first).\n          if (!deferredMeasurementCache.hasFixedWidth()) {\n            for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {\n              if (!deferredMeasurementCache.has(0, columnIndex)) {\n                rowStartIndex = 0;\n                rowStopIndex = rowCount - 1;\n                break;\n              }\n            }\n          }\n        }\n\n        this._childrenToDisplay = cellRangeRenderer({\n          cellCache: this._cellCache,\n          cellRenderer: cellRenderer,\n          columnSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\n          columnStartIndex: columnStartIndex,\n          columnStopIndex: columnStopIndex,\n          deferredMeasurementCache: deferredMeasurementCache,\n          horizontalOffsetAdjustment: horizontalOffsetAdjustment,\n          isScrolling: isScrolling,\n          isScrollingOptOut: isScrollingOptOut,\n          parent: this,\n          rowSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\n          rowStartIndex: rowStartIndex,\n          rowStopIndex: rowStopIndex,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          styleCache: this._styleCache,\n          verticalOffsetAdjustment: verticalOffsetAdjustment,\n          visibleColumnIndices: visibleColumnIndices,\n          visibleRowIndices: visibleRowIndices\n        });\n\n        // update the indices\n        this._columnStartIndex = columnStartIndex;\n        this._columnStopIndex = columnStopIndex;\n        this._rowStartIndex = rowStartIndex;\n        this._rowStopIndex = rowStopIndex;\n      }\n    }\n\n    /**\n     * Sets an :isScrolling flag for a small window of time.\n     * This flag is used to disable pointer events on the scrollable portion of the Grid.\n     * This prevents jerky/stuttery mouse-wheel scrolling.\n     */\n\n  }, {\n    key: '_debounceScrollEnded',\n    value: function _debounceScrollEnded() {\n      var scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;\n\n\n      if (this._disablePointerEventsTimeoutId) {\n        (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId);\n      }\n\n      this._disablePointerEventsTimeoutId = (0, _requestAnimationTimeout.requestAnimationTimeout)(this._debounceScrollEndedCallback, scrollingResetTimeInterval);\n    }\n  }, {\n    key: '_handleInvalidatedGridSize',\n\n\n    /**\n     * Check for batched CellMeasurer size invalidations.\n     * This will occur the first time one or more previously unmeasured cells are rendered.\n     */\n    value: function _handleInvalidatedGridSize() {\n      if (typeof this._deferredInvalidateColumnIndex === 'number' && typeof this._deferredInvalidateRowIndex === 'number') {\n        var columnIndex = this._deferredInvalidateColumnIndex;\n        var rowIndex = this._deferredInvalidateRowIndex;\n\n        this._deferredInvalidateColumnIndex = null;\n        this._deferredInvalidateRowIndex = null;\n\n        this.recomputeGridSize({ columnIndex: columnIndex, rowIndex: rowIndex });\n      }\n    }\n  }, {\n    key: '_invokeOnScrollMemoizer',\n    value: function _invokeOnScrollMemoizer(_ref6) {\n      var _this3 = this;\n\n      var scrollLeft = _ref6.scrollLeft,\n          scrollTop = _ref6.scrollTop,\n          totalColumnsWidth = _ref6.totalColumnsWidth,\n          totalRowsHeight = _ref6.totalRowsHeight;\n\n      this._onScrollMemoizer({\n        callback: function callback(_ref7) {\n          var scrollLeft = _ref7.scrollLeft,\n              scrollTop = _ref7.scrollTop;\n          var _props7 = _this3.props,\n              height = _props7.height,\n              onScroll = _props7.onScroll,\n              width = _props7.width;\n\n\n          onScroll({\n            clientHeight: height,\n            clientWidth: width,\n            scrollHeight: totalRowsHeight,\n            scrollLeft: scrollLeft,\n            scrollTop: scrollTop,\n            scrollWidth: totalColumnsWidth\n          });\n        },\n        indices: {\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        }\n      });\n    }\n  }, {\n    key: '_isScrolling',\n    value: function _isScrolling() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      // If isScrolling is defined in props, use it to override the value in state\n      // This is a performance optimization for WindowScroller + Grid\n      return Object.hasOwnProperty.call(props, 'isScrolling') ? Boolean(props.isScrolling) : Boolean(state.isScrolling);\n    }\n  }, {\n    key: '_maybeCallOnScrollbarPresenceChange',\n    value: function _maybeCallOnScrollbarPresenceChange() {\n      if (this._scrollbarPresenceChanged) {\n        var _onScrollbarPresenceChange = this.props.onScrollbarPresenceChange;\n\n\n        this._scrollbarPresenceChanged = false;\n\n        _onScrollbarPresenceChange({\n          horizontal: this._horizontalScrollBarSize > 0,\n          size: this.state.instanceProps.scrollbarSize,\n          vertical: this._verticalScrollBarSize > 0\n        });\n      }\n    }\n  }, {\n    key: 'scrollToPosition',\n\n\n    /**\n     * Scroll to the specified offset(s).\n     * Useful for animating position changes.\n     */\n    value: function scrollToPosition(_ref8) {\n      var scrollLeft = _ref8.scrollLeft,\n          scrollTop = _ref8.scrollTop;\n\n      var stateUpdate = Grid._getScrollToPositionStateUpdate({\n        prevState: this.state,\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop\n      });\n\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }, {\n    key: '_getCalculatedScrollLeft',\n    value: function _getCalculatedScrollLeft() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      return Grid._getCalculatedScrollLeft(props, state);\n    }\n  }, {\n    key: '_updateScrollLeftForScrollToColumn',\n    value: function _updateScrollLeftForScrollToColumn() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      var stateUpdate = Grid._getScrollLeftForScrollToColumnStateUpdate(props, state);\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }, {\n    key: '_getCalculatedScrollTop',\n    value: function _getCalculatedScrollTop() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      return Grid._getCalculatedScrollTop(props, state);\n    }\n  }, {\n    key: '_resetStyleCache',\n    value: function _resetStyleCache() {\n      var styleCache = this._styleCache;\n      var cellCache = this._cellCache;\n      var isScrollingOptOut = this.props.isScrollingOptOut;\n\n      // Reset cell and style caches once scrolling stops.\n      // This makes Grid simpler to use (since cells commonly change).\n      // And it keeps the caches from growing too large.\n      // Performance is most sensitive when a user is scrolling.\n      // Don't clear visible cells from cellCache if isScrollingOptOut is specified.\n      // This keeps the cellCache to a resonable size.\n\n      this._cellCache = {};\n      this._styleCache = {};\n\n      // Copy over the visible cell styles so avoid unnecessary re-render.\n      for (var rowIndex = this._rowStartIndex; rowIndex <= this._rowStopIndex; rowIndex++) {\n        for (var columnIndex = this._columnStartIndex; columnIndex <= this._columnStopIndex; columnIndex++) {\n          var key = rowIndex + '-' + columnIndex;\n          this._styleCache[key] = styleCache[key];\n\n          if (isScrollingOptOut) {\n            this._cellCache[key] = cellCache[key];\n          }\n        }\n      }\n    }\n  }, {\n    key: '_updateScrollTopForScrollToRow',\n    value: function _updateScrollTopForScrollToRow() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      var stateUpdate = Grid._getScrollTopForScrollToRowStateUpdate(props, state);\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }], [{\n    key: 'getDerivedStateFromProps',\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var newState = {};\n\n      if (nextProps.columnCount === 0 && prevState.scrollLeft !== 0 || nextProps.rowCount === 0 && prevState.scrollTop !== 0) {\n        newState.scrollLeft = 0;\n        newState.scrollTop = 0;\n\n        // only use scroll{Left,Top} from props if scrollTo{Column,Row} isn't specified\n        // scrollTo{Column,Row} should override scroll{Left,Top}\n      } else if (nextProps.scrollLeft !== prevState.scrollLeft && nextProps.scrollToColumn < 0 || nextProps.scrollTop !== prevState.scrollTop && nextProps.scrollToRow < 0) {\n        (0, _assign2.default)(newState, Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: nextProps.scrollLeft,\n          scrollTop: nextProps.scrollTop\n        }));\n      }\n\n      var instanceProps = prevState.instanceProps;\n\n      // Initially we should not clearStyleCache\n\n      newState.needToResetStyleCache = false;\n      if (nextProps.columnWidth !== instanceProps.prevColumnWidth || nextProps.rowHeight !== instanceProps.prevRowHeight) {\n        // Reset cache. set it to {} in render\n        newState.needToResetStyleCache = true;\n      }\n\n      instanceProps.columnSizeAndPositionManager.configure({\n        cellCount: nextProps.columnCount,\n        estimatedCellSize: Grid._getEstimatedColumnSize(nextProps),\n        cellSizeGetter: Grid._wrapSizeGetter(nextProps.columnWidth)\n      });\n\n      instanceProps.rowSizeAndPositionManager.configure({\n        cellCount: nextProps.rowCount,\n        estimatedCellSize: Grid._getEstimatedRowSize(nextProps),\n        cellSizeGetter: Grid._wrapSizeGetter(nextProps.rowHeight)\n      });\n\n      if (instanceProps.prevColumnCount === 0 || instanceProps.prevRowCount === 0) {\n        instanceProps.prevColumnCount = 0;\n        instanceProps.prevRowCount = 0;\n      }\n\n      // If scrolling is controlled outside this component, clear cache when scrolling stops\n      if (nextProps.autoHeight && nextProps.isScrolling === false && instanceProps.prevIsScrolling === true) {\n        (0, _assign2.default)(newState, {\n          isScrolling: false\n        });\n      }\n\n      var maybeStateA = void 0;\n      var maybeStateB = void 0;\n\n      (0, _calculateSizeAndPositionDataAndUpdateScrollOffset2.default)({\n        cellCount: instanceProps.prevColumnCount,\n        cellSize: typeof instanceProps.prevColumnWidth === 'number' ? instanceProps.prevColumnWidth : null,\n        computeMetadataCallback: function computeMetadataCallback() {\n          return instanceProps.columnSizeAndPositionManager.resetCell(0);\n        },\n        computeMetadataCallbackProps: nextProps,\n        nextCellsCount: nextProps.columnCount,\n        nextCellSize: typeof nextProps.columnWidth === 'number' ? nextProps.columnWidth : null,\n        nextScrollToIndex: nextProps.scrollToColumn,\n        scrollToIndex: instanceProps.prevScrollToColumn,\n        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {\n          maybeStateA = Grid._getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState);\n        }\n      });\n      (0, _calculateSizeAndPositionDataAndUpdateScrollOffset2.default)({\n        cellCount: instanceProps.prevRowCount,\n        cellSize: typeof instanceProps.prevRowHeight === 'number' ? instanceProps.prevRowHeight : null,\n        computeMetadataCallback: function computeMetadataCallback() {\n          return instanceProps.rowSizeAndPositionManager.resetCell(0);\n        },\n        computeMetadataCallbackProps: nextProps,\n        nextCellsCount: nextProps.rowCount,\n        nextCellSize: typeof nextProps.rowHeight === 'number' ? nextProps.rowHeight : null,\n        nextScrollToIndex: nextProps.scrollToRow,\n        scrollToIndex: instanceProps.prevScrollToRow,\n        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {\n          maybeStateB = Grid._getScrollTopForScrollToRowStateUpdate(nextProps, prevState);\n        }\n      });\n\n      instanceProps.prevColumnCount = nextProps.columnCount;\n      instanceProps.prevColumnWidth = nextProps.columnWidth;\n      instanceProps.prevIsScrolling = nextProps.isScrolling === true;\n      instanceProps.prevRowCount = nextProps.rowCount;\n      instanceProps.prevRowHeight = nextProps.rowHeight;\n      instanceProps.prevScrollToColumn = nextProps.scrollToColumn;\n      instanceProps.prevScrollToRow = nextProps.scrollToRow;\n\n      // getting scrollBarSize (moved from componentWillMount)\n      instanceProps.scrollbarSize = nextProps.getScrollbarSize();\n      if (instanceProps.scrollbarSize === undefined) {\n        instanceProps.scrollbarSizeMeasured = false;\n        instanceProps.scrollbarSize = 0;\n      } else {\n        instanceProps.scrollbarSizeMeasured = true;\n      }\n\n      newState.instanceProps = instanceProps;\n\n      return (0, _extends3.default)({}, newState, maybeStateA, maybeStateB);\n    }\n  }, {\n    key: '_getEstimatedColumnSize',\n    value: function _getEstimatedColumnSize(props) {\n      return typeof props.columnWidth === 'number' ? props.columnWidth : props.estimatedColumnSize;\n    }\n  }, {\n    key: '_getEstimatedRowSize',\n    value: function _getEstimatedRowSize(props) {\n      return typeof props.rowHeight === 'number' ? props.rowHeight : props.estimatedRowSize;\n    }\n  }, {\n    key: '_getScrollToPositionStateUpdate',\n\n\n    /**\n     * Get the updated state after scrolling to\n     * scrollLeft and scrollTop\n     */\n    value: function _getScrollToPositionStateUpdate(_ref9) {\n      var prevState = _ref9.prevState,\n          scrollLeft = _ref9.scrollLeft,\n          scrollTop = _ref9.scrollTop;\n\n      var newState = {\n        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n      };\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0) {\n        newState.scrollDirectionHorizontal = scrollLeft > prevState.scrollLeft ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD;\n        newState.scrollLeft = scrollLeft;\n      }\n\n      if (typeof scrollTop === 'number' && scrollTop >= 0) {\n        newState.scrollDirectionVertical = scrollTop > prevState.scrollTop ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD;\n        newState.scrollTop = scrollTop;\n      }\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft || typeof scrollTop === 'number' && scrollTop >= 0 && scrollTop !== prevState.scrollTop) {\n        return newState;\n      }\n      return null;\n    }\n  }, {\n    key: '_wrapSizeGetter',\n    value: function _wrapSizeGetter(value) {\n      return typeof value === 'function' ? value : function () {\n        return value;\n      };\n    }\n  }, {\n    key: '_getCalculatedScrollLeft',\n    value: function _getCalculatedScrollLeft(nextProps, prevState) {\n      var columnCount = nextProps.columnCount,\n          height = nextProps.height,\n          scrollToAlignment = nextProps.scrollToAlignment,\n          scrollToColumn = nextProps.scrollToColumn,\n          width = nextProps.width;\n      var scrollLeft = prevState.scrollLeft,\n          instanceProps = prevState.instanceProps;\n\n\n      if (columnCount > 0) {\n        var finalColumn = columnCount - 1;\n        var targetIndex = scrollToColumn < 0 ? finalColumn : Math.min(finalColumn, scrollToColumn);\n        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n        var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\n\n        return instanceProps.columnSizeAndPositionManager.getUpdatedOffsetForIndex({\n          align: scrollToAlignment,\n          containerSize: width - scrollBarSize,\n          currentOffset: scrollLeft,\n          targetIndex: targetIndex\n        });\n      }\n      return 0;\n    }\n  }, {\n    key: '_getScrollLeftForScrollToColumnStateUpdate',\n    value: function _getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState) {\n      var scrollLeft = prevState.scrollLeft;\n\n      var calculatedScrollLeft = Grid._getCalculatedScrollLeft(nextProps, prevState);\n\n      if (typeof calculatedScrollLeft === 'number' && calculatedScrollLeft >= 0 && scrollLeft !== calculatedScrollLeft) {\n        return Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: calculatedScrollLeft,\n          scrollTop: -1\n        });\n      }\n      return null;\n    }\n  }, {\n    key: '_getCalculatedScrollTop',\n    value: function _getCalculatedScrollTop(nextProps, prevState) {\n      var height = nextProps.height,\n          rowCount = nextProps.rowCount,\n          scrollToAlignment = nextProps.scrollToAlignment,\n          scrollToRow = nextProps.scrollToRow,\n          width = nextProps.width;\n      var scrollTop = prevState.scrollTop,\n          instanceProps = prevState.instanceProps;\n\n\n      if (rowCount > 0) {\n        var finalRow = rowCount - 1;\n        var targetIndex = scrollToRow < 0 ? finalRow : Math.min(finalRow, scrollToRow);\n        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n        var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\n\n        return instanceProps.rowSizeAndPositionManager.getUpdatedOffsetForIndex({\n          align: scrollToAlignment,\n          containerSize: height - scrollBarSize,\n          currentOffset: scrollTop,\n          targetIndex: targetIndex\n        });\n      }\n      return 0;\n    }\n  }, {\n    key: '_getScrollTopForScrollToRowStateUpdate',\n    value: function _getScrollTopForScrollToRowStateUpdate(nextProps, prevState) {\n      var scrollTop = prevState.scrollTop;\n\n      var calculatedScrollTop = Grid._getCalculatedScrollTop(nextProps, prevState);\n\n      if (typeof calculatedScrollTop === 'number' && calculatedScrollTop >= 0 && scrollTop !== calculatedScrollTop) {\n        return Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: -1,\n          scrollTop: calculatedScrollTop\n        });\n      }\n      return null;\n    }\n  }]);\n  return Grid;\n}(React.PureComponent);\n\nGrid.defaultProps = {\n  'aria-label': 'grid',\n  'aria-readonly': true,\n  autoContainerWidth: false,\n  autoHeight: false,\n  autoWidth: false,\n  cellRangeRenderer: _defaultCellRangeRenderer2.default,\n  containerRole: 'rowgroup',\n  containerStyle: {},\n  estimatedColumnSize: 100,\n  estimatedRowSize: 30,\n  getScrollbarSize: _scrollbarSize2.default,\n  noContentRenderer: renderNull,\n  onScroll: function onScroll() {},\n  onScrollbarPresenceChange: function onScrollbarPresenceChange() {},\n  onSectionRendered: function onSectionRendered() {},\n  overscanColumnCount: 0,\n  overscanIndicesGetter: _defaultOverscanIndicesGetter2.default,\n  overscanRowCount: 10,\n  role: 'grid',\n  scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL,\n  scrollToAlignment: 'auto',\n  scrollToColumn: -1,\n  scrollToRow: -1,\n  style: {},\n  tabIndex: 0,\n  isScrollingOptOut: false\n};\nGrid.propTypes = process.env.NODE_ENV === 'production' ? null : {\n  \"aria-label\": _propTypes2.default.string.isRequired,\n  \"aria-readonly\": _propTypes2.default.bool,\n\n\n  /**\n   * Set the width of the inner scrollable container to 'auto'.\n   * This is useful for single-column Grids to ensure that the column doesn't extend below a vertical scrollbar.\n   */\n  autoContainerWidth: _propTypes2.default.bool.isRequired,\n\n\n  /**\n   * Removes fixed height from the scrollingContainer so that the total height of rows can stretch the window.\n   * Intended for use with WindowScroller\n   */\n  autoHeight: _propTypes2.default.bool.isRequired,\n\n\n  /**\n   * Removes fixed width from the scrollingContainer so that the total width of rows can stretch the window.\n   * Intended for use with WindowScroller\n   */\n  autoWidth: _propTypes2.default.bool.isRequired,\n\n\n  /** Responsible for rendering a cell given an row and column index.  */\n  cellRenderer: function cellRenderer() {\n    return (typeof _types.bpfrpt_proptype_CellRenderer === 'function' ? _types.bpfrpt_proptype_CellRenderer.isRequired ? _types.bpfrpt_proptype_CellRenderer.isRequired : _types.bpfrpt_proptype_CellRenderer : _propTypes2.default.shape(_types.bpfrpt_proptype_CellRenderer).isRequired).apply(this, arguments);\n  },\n\n\n  /** Responsible for rendering a group of cells given their index ranges.  */\n  cellRangeRenderer: function cellRangeRenderer() {\n    return (typeof _types.bpfrpt_proptype_CellRangeRenderer === 'function' ? _types.bpfrpt_proptype_CellRangeRenderer.isRequired ? _types.bpfrpt_proptype_CellRangeRenderer.isRequired : _types.bpfrpt_proptype_CellRangeRenderer : _propTypes2.default.shape(_types.bpfrpt_proptype_CellRangeRenderer).isRequired).apply(this, arguments);\n  },\n\n\n  /** Optional custom CSS class name to attach to root Grid element.  */\n  className: _propTypes2.default.string,\n\n\n  /** Number of columns in grid.  */\n  columnCount: _propTypes2.default.number.isRequired,\n\n\n  /** Either a fixed column width (number) or a function that returns the width of a column given its index.  */\n  columnWidth: function columnWidth() {\n    return (typeof _types.bpfrpt_proptype_CellSize === 'function' ? _types.bpfrpt_proptype_CellSize.isRequired ? _types.bpfrpt_proptype_CellSize.isRequired : _types.bpfrpt_proptype_CellSize : _propTypes2.default.shape(_types.bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);\n  },\n\n\n  /** Unfiltered props for the Grid container. */\n  containerProps: _propTypes2.default.object,\n\n\n  /** ARIA role for the cell-container.  */\n  containerRole: _propTypes2.default.string.isRequired,\n\n\n  /** Optional inline style applied to inner cell-container */\n  containerStyle: _propTypes2.default.object.isRequired,\n\n\n  /**\n   * If CellMeasurer is used to measure this Grid's children, this should be a pointer to its CellMeasurerCache.\n   * A shared CellMeasurerCache reference enables Grid and CellMeasurer to share measurement data.\n   */\n  deferredMeasurementCache: _propTypes2.default.object,\n\n\n  /**\n   * Used to estimate the total width of a Grid before all of its columns have actually been measured.\n   * The estimated total width is adjusted as columns are rendered.\n   */\n  estimatedColumnSize: _propTypes2.default.number.isRequired,\n\n\n  /**\n   * Used to estimate the total height of a Grid before all of its rows have actually been measured.\n   * The estimated total height is adjusted as rows are rendered.\n   */\n  estimatedRowSize: _propTypes2.default.number.isRequired,\n\n\n  /** Exposed for testing purposes only.  */\n  getScrollbarSize: _propTypes2.default.func.isRequired,\n\n\n  /** Height of Grid; this property determines the number of visible (vs virtualized) rows.  */\n  height: _propTypes2.default.number.isRequired,\n\n\n  /** Optional custom id to attach to root Grid element.  */\n  id: _propTypes2.default.string,\n\n\n  /**\n   * Override internal is-scrolling state tracking.\n   * This property is primarily intended for use with the WindowScroller component.\n   */\n  isScrolling: _propTypes2.default.bool,\n\n\n  /**\n   * Opt-out of isScrolling param passed to cellRangeRenderer.\n   * To avoid the extra render when scroll stops.\n   */\n  isScrollingOptOut: _propTypes2.default.bool.isRequired,\n\n\n  /** Optional renderer to be used in place of rows when either :rowCount or :columnCount is 0.  */\n  noContentRenderer: function noContentRenderer() {\n    return (typeof _types.bpfrpt_proptype_NoContentRenderer === 'function' ? _types.bpfrpt_proptype_NoContentRenderer.isRequired ? _types.bpfrpt_proptype_NoContentRenderer.isRequired : _types.bpfrpt_proptype_NoContentRenderer : _propTypes2.default.shape(_types.bpfrpt_proptype_NoContentRenderer).isRequired).apply(this, arguments);\n  },\n\n\n  /**\n   * Callback invoked whenever the scroll offset changes within the inner scrollable region.\n   * This callback can be used to sync scrolling between lists, tables, or grids.\n   */\n  onScroll: _propTypes2.default.func.isRequired,\n\n\n  /**\n   * Called whenever a horizontal or vertical scrollbar is added or removed.\n   * This prop is not intended for end-user use;\n   * It is used by MultiGrid to support fixed-row/fixed-column scroll syncing.\n   */\n  onScrollbarPresenceChange: _propTypes2.default.func.isRequired,\n\n\n  /** Callback invoked with information about the section of the Grid that was just rendered.  */\n  onSectionRendered: _propTypes2.default.func.isRequired,\n\n\n  /**\n   * Number of columns to render before/after the visible section of the grid.\n   * These columns can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.\n   */\n  overscanColumnCount: _propTypes2.default.number.isRequired,\n\n\n  /**\n   * Calculates the number of cells to overscan before and after a specified range.\n   * This function ensures that overscanning doesn't exceed the available cells.\n   */\n  overscanIndicesGetter: function overscanIndicesGetter() {\n    return (typeof _types.bpfrpt_proptype_OverscanIndicesGetter === 'function' ? _types.bpfrpt_proptype_OverscanIndicesGetter.isRequired ? _types.bpfrpt_proptype_OverscanIndicesGetter.isRequired : _types.bpfrpt_proptype_OverscanIndicesGetter : _propTypes2.default.shape(_types.bpfrpt_proptype_OverscanIndicesGetter).isRequired).apply(this, arguments);\n  },\n\n\n  /**\n   * Number of rows to render above/below the visible section of the grid.\n   * These rows can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.\n   */\n  overscanRowCount: _propTypes2.default.number.isRequired,\n\n\n  /** ARIA role for the grid element.  */\n  role: _propTypes2.default.string.isRequired,\n\n\n  /**\n   * Either a fixed row height (number) or a function that returns the height of a row given its index.\n   * Should implement the following interface: ({ index: number }): number\n   */\n  rowHeight: function rowHeight() {\n    return (typeof _types.bpfrpt_proptype_CellSize === 'function' ? _types.bpfrpt_proptype_CellSize.isRequired ? _types.bpfrpt_proptype_CellSize.isRequired : _types.bpfrpt_proptype_CellSize : _propTypes2.default.shape(_types.bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);\n  },\n\n\n  /** Number of rows in grid.  */\n  rowCount: _propTypes2.default.number.isRequired,\n\n\n  /** Wait this amount of time after the last scroll event before resetting Grid `pointer-events`. */\n  scrollingResetTimeInterval: _propTypes2.default.number.isRequired,\n\n\n  /** Horizontal offset. */\n  scrollLeft: _propTypes2.default.number,\n\n\n  /**\n   * Controls scroll-to-cell behavior of the Grid.\n   * The default (\"auto\") scrolls the least amount possible to ensure that the specified cell is fully visible.\n   * Use \"start\" to align cells to the top/left of the Grid and \"end\" to align bottom/right.\n   */\n  scrollToAlignment: function scrollToAlignment() {\n    return (typeof _types.bpfrpt_proptype_Alignment === 'function' ? _types.bpfrpt_proptype_Alignment.isRequired ? _types.bpfrpt_proptype_Alignment.isRequired : _types.bpfrpt_proptype_Alignment : _propTypes2.default.shape(_types.bpfrpt_proptype_Alignment).isRequired).apply(this, arguments);\n  },\n\n\n  /** Column index to ensure visible (by forcefully scrolling if necessary) */\n  scrollToColumn: _propTypes2.default.number.isRequired,\n\n\n  /** Vertical offset. */\n  scrollTop: _propTypes2.default.number,\n\n\n  /** Row index to ensure visible (by forcefully scrolling if necessary) */\n  scrollToRow: _propTypes2.default.number.isRequired,\n\n\n  /** Optional inline style */\n  style: _propTypes2.default.object.isRequired,\n\n\n  /** Tab index for focus */\n  tabIndex: _propTypes2.default.number,\n\n\n  /** Width of Grid; this property determines the number of visible (vs virtualized) columns.  */\n  width: _propTypes2.default.number.isRequired\n};\n\n\n(0, _reactLifecyclesCompat.polyfill)(Grid);\nexports.default = Grid;"]},"metadata":{},"sourceType":"script"}