import * as React from 'react';
export declare type IsAny<T> = boolean extends (T extends never ? true : false) ? true : false;
export declare type IsFlatObject<T extends Record<string, unknown>> = Extract<T[keyof T], unknown[] | Record<string, unknown>> extends never ? true : false;
export declare type Primitive = string | boolean | number | symbol | null | undefined;
export declare type LiteralToPrimitive<T extends any> = T extends string ? string : T extends number ? number : T extends boolean ? boolean : T;
export declare type FieldValues = Record<string, any>;
export declare type FieldName<FormValues extends FieldValues> = (keyof FormValues & string) | string;
export declare type FieldValue<FormValues extends FieldValues> = FormValues[FieldName<FormValues>];
export declare type Ref = FieldElement;
export declare type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends Array<infer U> ? Array<DeepPartial<U>> : T[P] extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T[P] extends {
        [key: string]: unknown;
    } ? DeepPartial<T[P]> : T[P];
};
export declare type ValidationMode = {
    onBlur: 'onBlur';
    onChange: 'onChange';
    onSubmit: 'onSubmit';
};
export declare type Mode = keyof ValidationMode;
export declare type OnSubmit<FormValues extends FieldValues> = (data: FormValues, event?: React.BaseSyntheticEvent) => void | Promise<void>;
export declare type SchemaValidateOptions = Partial<{
    strict: boolean;
    abortEarly: boolean;
    stripUnknown: boolean;
    recursive: boolean;
    context: any;
}>;
export declare type EmptyObject = {
    [key in string | number]: never;
};
export declare type SchemaValidationSuccess<FormValues extends FieldValues = FieldValues> = {
    values: FormValues;
    errors: EmptyObject;
};
export declare type SchemaValidationError<FormValues extends FieldValues = FieldValues> = {
    values: EmptyObject;
    errors: FieldErrors<FormValues>;
};
export declare type SchemaValidationResult<FormValues extends FieldValues = FieldValues> = SchemaValidationSuccess<FormValues> | SchemaValidationError<FormValues>;
export declare type ValidationResolver<FormValues extends FieldValues = FieldValues, ValidationContext extends object = object> = (values: FormValues, validationContext?: ValidationContext) => SchemaValidationResult<FormValues> | Promise<SchemaValidationResult<FormValues>>;
export declare type UseFormOptions<FormValues extends FieldValues = FieldValues, ValidationContext extends object = object> = Partial<{
    mode: Mode;
    reValidateMode: Mode;
    defaultValues: DeepPartial<FormValues>;
    validationSchema: any;
    validationResolver: ValidationResolver<FormValues, ValidationContext>;
    validationContext: ValidationContext;
    submitFocusError: boolean;
    validateCriteriaMode: 'firstError' | 'all';
}>;
export declare type MutationWatcher = {
    disconnect: VoidFunction;
    observe?: any;
};
export declare type Message = string | React.ReactElement;
export declare type ValidationValue = boolean | number | string | RegExp;
export declare type ValidationOption<Value extends ValidationValue = ValidationValue> = Value | ValidationValueMessage<Value>;
export declare type ValidationValueMessage<Value extends ValidationValue = ValidationValue> = {
    value: Value;
    message: Message;
};
export declare type ValidateResult = Message | boolean | undefined;
export declare type Validate = (data: any) => ValidateResult | Promise<ValidateResult>;
export declare type ValidationOptions = Partial<{
    required: Message | ValidationOption<boolean>;
    min: ValidationOption<number | string>;
    max: ValidationOption<number | string>;
    maxLength: ValidationOption<number | string>;
    minLength: ValidationOption<number | string>;
    pattern: ValidationOption<RegExp>;
    validate: Validate | Record<string, Validate>;
}>;
export declare type MultipleFieldErrors = Record<string, ValidateResult>;
export declare type FieldError = {
    type: string;
    ref?: Ref;
    types?: MultipleFieldErrors;
    message?: Message;
    isManual?: boolean;
};
export declare type ManualFieldError<FormValues> = {
    name: FieldName<FormValues>;
    type: string;
    types?: MultipleFieldErrors;
    message?: Message;
};
export declare type Field = {
    ref: Ref;
    mutationWatcher?: MutationWatcher;
    options?: RadioOrCheckboxOption[];
} & ValidationOptions;
export declare type FieldRefs<FormValues extends FieldValues> = Partial<Record<FieldName<FormValues>, Field>>;
export declare type NestDataObject<FormValues, Value> = {
    [Key in keyof FormValues]?: FormValues[Key] extends Array<infer U> ? IsAny<U> extends true ? any : unknown extends U ? Value[] : object extends U ? Value[] : U extends Date ? Value[] : U extends object ? NestDataObject<U, Value>[] : Value[] : IsAny<FormValues[Key]> extends true ? any : unknown extends FormValues[Key] ? Value : object extends FormValues[Key] ? Value : FormValues[Key] extends Date ? Value : FormValues[Key] extends object ? NestDataObject<FormValues[Key], Value> : Value;
};
export declare type FieldErrors<FormValues> = NestDataObject<FormValues, FieldError>;
export declare type Touched<FormValues> = NestDataObject<FormValues, true>;
export declare type FormStateProxy<FormValues extends FieldValues = FieldValues> = {
    dirty: boolean;
    dirtyFields: Set<FieldName<FormValues>>;
    isSubmitted: boolean;
    submitCount: number;
    touched: Touched<FormValues>;
    isSubmitting: boolean;
    isValid: boolean;
};
export declare type ReadFormState = {
    [P in keyof FormStateProxy]: boolean;
};
export declare type RadioOrCheckboxOption = {
    ref: HTMLInputElement;
    mutationWatcher?: MutationWatcher;
};
export declare type CustomElement = {
    name: string;
    type?: string;
    value?: any;
    checked?: boolean;
    options?: HTMLOptionsCollection;
    files?: FileList | null;
    focus?: () => void;
};
export declare type FieldElement = HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement | CustomElement;
export declare type HandleChange = (evt: Event) => Promise<void | boolean>;
export declare type FormValuesFromErrors<Errors> = Errors extends FieldErrors<infer FormValues> ? FormValues : never;
export declare type EventFunction = (args: any[]) => any;
export declare type Control<FormValues extends FieldValues = FieldValues> = {
    register<Element extends FieldElement = FieldElement>(): (ref: Element | null) => void;
    register<Element extends FieldElement = FieldElement>(validationOptions: ValidationOptions): (ref: Element | null) => void;
    register<Element extends FieldElement = FieldElement>(name: FieldName<FormValues>, validationOptions?: ValidationOptions): void;
    register<Element extends FieldElement = FieldElement>(namesWithValidationOptions: Record<FieldName<FormValues>, ValidationOptions>): void;
    register<Element extends FieldElement = FieldElement>(ref: Element, validationOptions?: ValidationOptions): void;
    register<Element extends FieldElement = FieldElement>(refOrValidationOptions: ValidationOptions | Element | null, validationOptions?: ValidationOptions): ((ref: Element | null) => void) | void;
    reRender: () => void;
    removeFieldEventListener: (field: Field, forceDelete?: boolean) => void;
    unregister(name: FieldName<FormValues>): void;
    unregister(names: FieldName<FormValues>[]): void;
    unregister(names: FieldName<FormValues> | FieldName<FormValues>[]): void;
    setValue<T extends keyof FormValues>(namesWithValue: DeepPartial<Pick<FormValues, T>>[], shouldValidate?: boolean): void;
    setValue<T extends string, U extends unknown>(name: T, value: T extends keyof FormValues ? IsAny<FormValues[T]> extends true ? any : DeepPartial<FormValues[T]> : LiteralToPrimitive<U>, shouldValidate?: boolean): void;
    getValues(): IsFlatObject<FormValues> extends false ? Record<string, unknown> : FormValues;
    getValues<T extends boolean>(payload: {
        nest: T;
    }): T extends true ? FormValues : IsFlatObject<FormValues> extends true ? FormValues : Record<string, unknown>;
    getValues(payload?: {
        nest: boolean;
    }): FormValues;
    getValues<T extends string, U extends unknown>(payload: T): T extends keyof FormValues ? FormValues[T] : U;
    triggerValidation(payload?: (IsFlatObject<FormValues> extends true ? Extract<keyof FormValues, string> : string) | (IsFlatObject<FormValues> extends true ? Extract<keyof FormValues, string> : string)[]): Promise<boolean>;
    formState: FormStateProxy<FormValues>;
    mode: {
        isOnBlur: boolean;
        isOnSubmit: boolean;
        isOnChange: boolean;
    };
    reValidateMode: {
        isReValidateOnBlur: boolean;
        isReValidateOnSubmit: boolean;
    };
    fieldArrayDefaultValues: React.MutableRefObject<Record<string, any[]>>;
    dirtyFieldsRef: React.MutableRefObject<Set<FieldName<FormValues>>>;
    validateSchemaIsValid?: (fieldsValues: any) => void;
    touchedFieldsRef: React.MutableRefObject<Touched<FormValues>>;
    watchFieldsRef: React.MutableRefObject<Set<FieldName<FormValues>>>;
    isWatchAllRef: React.MutableRefObject<boolean>;
    validFieldsRef: React.MutableRefObject<Set<FieldName<FormValues>>>;
    fieldsWithValidationRef: React.MutableRefObject<Set<FieldName<FormValues>>>;
    errorsRef: React.MutableRefObject<FieldErrors<FormValues>>;
    fieldsRef: React.MutableRefObject<FieldRefs<FormValues>>;
    resetFieldArrayFunctionRef: React.MutableRefObject<Record<string, (values: any) => void>>;
    fieldArrayNamesRef: React.MutableRefObject<Set<string>>;
    isDirtyRef: React.MutableRefObject<boolean>;
    readFormStateRef: React.MutableRefObject<{
        dirty: boolean;
        isSubmitted: boolean;
        submitCount: boolean;
        touched: boolean;
        isSubmitting: boolean;
        isValid: boolean;
        dirtyFields: boolean;
    }>;
    defaultValuesRef: React.MutableRefObject<DeepPartial<FormValues> | FormValues[FieldName<FormValues>]>;
};
export declare type Assign<T extends object, U extends object> = T & Omit<U, keyof T>;
export declare type AsProps<As> = As extends undefined ? {} : As extends React.ReactElement ? {
    [key: string]: any;
} : As extends React.ComponentType<infer P> ? P : As extends keyof JSX.IntrinsicElements ? JSX.IntrinsicElements[As] : never;
export declare type ControllerProps<As extends React.ReactElement | React.ComponentType<any> | keyof JSX.IntrinsicElements, ControlProp extends Control = Control> = Assign<{
    name: string;
    as: As;
    rules?: ValidationOptions;
    onChange?: EventFunction;
    onFocus?: () => void;
    onBlur?: EventFunction;
    mode?: Mode;
    onChangeName?: string;
    onBlurName?: string;
    valueName?: string;
    defaultValue?: unknown;
    control?: ControlProp;
}, AsProps<As>>;
export declare type ErrorMessageProps<Errors extends FieldErrors<any>, Name extends FieldName<FormValuesFromErrors<Errors>>, As extends undefined | React.ReactElement | React.ComponentType<any> | keyof JSX.IntrinsicElements = undefined> = Assign<{
    as?: As;
    errors?: Errors;
    name: Name;
    message?: Message;
    children?: (data: {
        message: Message;
        messages?: MultipleFieldErrors;
    }) => React.ReactNode;
}, AsProps<As>>;
export declare type UseFieldArrayProps<KeyName extends string = 'id', ControlProp extends Control = Control> = {
    name: string;
    keyName?: KeyName;
    control?: ControlProp;
};
export declare type ArrayField<FormArrayValues extends FieldValues = FieldValues, KeyName extends string = 'id'> = FormArrayValues & Record<KeyName, string>;
export declare type OmitResetState = Partial<{
    errors: boolean;
    dirty: boolean;
    dirtyFields: boolean;
    isSubmitted: boolean;
    touched: boolean;
    isValid: boolean;
    submitCount: boolean;
}>;
